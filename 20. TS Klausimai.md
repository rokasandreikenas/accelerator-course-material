# TypeScript Klausimai

1. Kas yra TypeScript ir kuo jis skiriasi nuo JavaScript?

	TypeScript yra statiškai tipizuotas JavaScript superrinkinys (_superset_), sukurtas ir palaikomas „Microsoft“. Jis užtikrina geresnį kodo palaikomumą ir nuspėjamumą (_maintainability and predictability_). Po kompiliavimo TypeScript kodas yra transpiliuojamas (_transpiled_) į standartinį, naršyklėms pažystamą (_browser-compatible_) JavaScript kodą.

	**Pagrindiniai skirtumai tarp TypeScript ir JavaScript** apima tipų anotacijų (_type annotations_) naudojimą, galimybę dirbti su esamu JavaScript kodu ir dar daugiau.

	#### TypeScript savybės ir privalumai (_Features & Benefits_)

	-   **Tipų sistema**: Siūlo statinį tipavimą, leidžiantį programuotojams apibrėžti kintamųjų, parametrų ir grąžinimo reikšmių tipus. Tai padeda aptikti klaidas programų kūrimo metu (_developement_), sumažinant problemas vykdymo metu (_reducing runtime issues_).
	    
	-   **Pažangios kalbos savybės (_Advanced Language Features_)**: Įtraukia modernią ECMAScript sintaksę ir savybes (_features_), dažnai anksčiau nei jos įtraukiamos į JavaScript. Be to, TypeScript suteikia funkcinius programavimo šablonus, klases ir prieigos modifikatorius (_access modifiers_) (pvz., `public` ir `private`).
	    
	-   **Suderinamumas su JavaScript**: TypeScript gali interpretuoti esamą JavaScript kodą su minimaliomis modifikacijomis arba jų.
	    
	-   **Įrankiai ir papildomas saugumas**: Teikia patobulintą automatinį užbaigimą (_autocompletion_), refaktoringą ir dokumentaciją per TypeScript suprantančius įrankius (_TypeScript-aware tools_). TypeScript padeda aptikti ir ištaisyti dažnas programavimo klaidas nereikalaujant paleisti kodo.
	    
	-   **ECMAScript suderinamumas**: TypeScript leidžia kūrėjams taikyti skirtingas ECMAScript versijas, užtikrinant, kad sugeneruotas JavaScript būtų suderinamas su naudojamomi naršyklėmis (_targeted browsers_).
	    
	-   **Kodo struktūra ir skaitomumas**: Skatina palaikomumą (_maintainability_), įtvirtindamas apibrėžtą kodo struktūrą ir skatindamas kodo aiškumą (_code clarity_).
	    
	#### TypeScript vaidmuo šių dienų programavime (_development_)

	-   **Darbo vietos pritaikomumas**: TypeScript naudojamas įvairiuose projektuose - nuo mažų įrankių iki didelio masto programų.
	    
	-   **Bendruomenės palaikymas**: Turėdamas gyvybingą bendruomenę, TypeScript gauna dažnus atnaujinimus, klaidų taisymus ir naudingas plėtinius.
	    
	-   **Nuolatinė plėtra**: Tvirta kalbos serverio sistema užtikrina tikslius įrankių atsiliepimus (_feedback_), tokius kaip lintingas ir klaidų pasiūlymai realiuoju laiku.
	    
	-   **Sparti plėtra**: TypeScript komanda nuolat įveda naujas funkcijas ir stiprina esamas.

2. Kas reiškia, kad „TypeScript yra JavaScript superrinkinys (_superset_ of _JavaScript_)“?

	TypeScript dažnai apibūdinamas kaip „JavaScript superrinkinys (_superset_ of _JavaScript_)“, nes kiekvienas taisyklingas (_valid_) JavaScript kodas taip pat yra taisyklingas (_valid_) TypeScript kodas.

	TypeScript yra sukurtas taip, kad pilnai naudotų esamą JavaScript sintaksę ir funkcionalumą. Tai užtikrina sklandų perėjimą programuotojams, norintiems naudotis TypeScript.

	#### Pagrindinės TypeScript savybės, viršijančios (_Features On Top_) JavaScript

	-   **Tipų apibrėžimai**: TypeScript įveda statinį tipavimą per tipų anotacijas. Šios anotacijos yra neprivalomos, todėl esamoms kodų bazėms galima palaipsniui diegti, jei joms tai nėra būtina.
	    
	-   **Naujesnės JavaScript funkcijos**: TypeScript praplečia JavaScript sintaksę, teikdamas palaikymą naujausiems ECMAScript standartams efektyviau per savo kompiliatorių, net jei pagrindinis JavaScript variklis dar jų nepalaiko.
	    
	-   **Įrankiai ir klaidų aptikimas**: TypeScript siūlo tvirtą tipų tikrinimą, padidintą kodo skaitomumą ir didesnį klaidų aptikimą kompiliavimo metu.

	#### Kodo demonstracija

	Čia pateiktas TypeScript kodas:

	```ts
	let num: number = 5;
	num = "this will raise a type error";
	```

3. Kokie yra pagrindiniai tipai, naudojami TypeScript?

	TypeScript suteikia įvairius pagrindinius tipus skirtingų duomenų rūšių apdorojimui, tokius kaip skaičiai (_number_), eilutės(_string_), loginės reikšmės (_boolean_), masyvai (_array_), _tuple_ ir kt.

	#### Dažniausiai naudojami pagrindiniai TypeScript tipai

	-   **Boolean**: Atspindi true/false reikšmes.
	    
	-   **Number**: Taikomas tiek sveikiesiems, tiek racionaliesiems skaičiams (skaičiams su kableliu).
	    
	-   **String**: Nurodo tekstinius duomenis.
	    
	-   **Array**: Suteikia lankstų būdą dirbti su struktūrizuotais duomenimis.
	    
	-   **Tuple**: Leidžia apibrėžti masyvus su fiksuotu elementų skaičiumi, kurių kiekvienas gali būti skirtingo duomenų tipo.
	    
	-   **Enum**: Suteikia nustatytą pavadintų konstantų rinkinį, tokių kaip dienos ar spalvos.
	    
	-   **Any**: Suteikia dinaminį tipą, kuris gali būti naudojamas apeinant tipo tikrinimą. Paprastai geriau vengti šio tipo, nes jis paneigia pagrindinę TypeScript paskirtį - statinį tipavimą. Tačiau yra tam tikrų atvejų, kai jis tampa būtinas.
	    
	-   **Void**: Paprastai naudojamas kaip funkcijų, kurios negrąžina (_return_) reikšmės, grąžinimo (_return_) tipas.
	    
	-   **Null** ir **Undefined**: Leidžia priskirti null ir undefined reikšmes. Tačiau šis funkcionalumas pagal numatytuosius nustatymus nėra įjungtas ir geriausiai tvarkomas naudojant TypeScript `strict` režimo nustatymus.
	    
	-   **Never**: Atspindi vertes, kurios niekada nepasitaiko (_never occur_). Pavyzdžiui, funkcijos, kurios niekada nepasibaigia arba visada išmeta klaidą, grąžinimo (_return_) tipas.
	    
	-   **Object**: Bet kuris JavaScript objektas.
	    
	-   **Function**: Nurodo funkcijos tipą.
	    

	#### Kodo pavyzdys: pagrindiniai TypeScript tipai

	Čia pateiktas TypeScript kodas:
	
	```ts
	// Boolean
	let isActive: boolean = true;

	// Number
	let age: number = 30;

	// String
	let title: string = "Manager";

	// Array
	let scores: number[] = [85, 90, 78];
	// or use a compact form: let scores: Array<number> = [85, 90, 78];

	// Tuple
	let employee: [string, number, boolean] = ['John', 35, true];

	// Enum
	enum WeekDays { Monday, Tuesday, Wednesday, Thursday, Friday }
	let today: WeekDays = WeekDays.Wednesday;

	// Any
	let dynamicData: any = 20;

	// Void
	function greet(): void {
	  console.log("Hello!");
	}

	// Null and Undefined
	let data: null = null;
	let user: undefined = undefined;

	// Never
	function errorMessage(message: string): never {
	  throw new Error(message);
	}

	// Object
	let person: object = {
	  name: 'John',
	  age: 30
	};

	// Function
	let calculate: Function;
	calculate = function (x: number, y: number): number {
	  return x + y;
	};
	```

4. Kaip deklaruoti kintamuosius TypeScript?

	TypeScript palaiko įvairius metodus kintamųjų ir jų tipų deklaravimui.

	#### Kintamųjų ir tipų deklaravimo metodai

	1. **`var`**

	```ts
	var score: number = 100;
	```
	
	Ši deklaracija gali sukelti kintamojo „pakėlimą“ (hoisting) ir turi globalų (_global scope_) arba funkcijos lygmens _scope_ (_function-level scope_).

	2. **`let`**

	Naudokite `let`, kai norite apibrėžti kintamuosius esančius _block scope_. Tai rekomenduojamas naudojimo būdas:

	```ts
	let playerName: string = "John";
	```

	3. **`const`**

	`const` leidžia deklaruoti konstantas ir yra ypač naudingas duomenų vientisumo (_data integrity_) išlaikymui:

	```ts
	const apiKey: string = "your-api-key-here";
	```

	4.  **Funkcijos _scope_**

	Visi trys metodai (`var`, `let` ir `const`) yra izoliuojami (_confined_) jų tiesioginės funkcijos _scope_ (_immediate function scope_):
	
	```ts
	function doSomething() {
	  let tempValue: number = 42;
	  var result: boolean = true;
	}
	```

	#### Kintamųjų deklaravimo ir inicializavimo taisyklės

	**Deklaracijos tvarka**: TypeScript reikia, kad kintamasis būtų deklaruotas prieš jį naudojant. Tai nėra būtina rašant JavaScript kodą, tačiau tai yra geroji praktika.
	
	Jei dirbate su sudėtingais ar tarpusavyje susijusiais kodais, geriausia praktika yra naudoti `let` ir `const` deklaracijas, kurios užtikrina bloko lygio sritį (_block-level scoping_), taip padedant spręsti galimas „pakėlimo“ (_hoisting_) problemas.

	**Statiniai tipai**: TypeScript reikalauja, kad deklaruotumėte kintamojo duomenų tipą (arba leistumėte sistemai tai daryti) ir tada inicializuotumėte jį su tos pačios rūšies reikšme:

	```ts
	let count: number;  // Declaration
	count = 42;  // Allowed
	count = "42";  // Error! Type 'string' is not assignable to type 'number'.
	```

	**Tipų išvedimas (_Type Inference_)**: TypeScript dažnai gali nustatyti kintamojo tipą pagal inicializacijos reikšmę. Tai sumažina poreikį aiškiai nurodyti tipą.

	```ts
	let word = "hello!";  // TypeScript infers the type as 'string' because of the initialization.
	```

	#### Geriausios praktikos kintamųjų deklaravimui

	-   **Naudokite `const`, kai tik galite**: Šis būdas ne visada įmanomas, ypač kai dirbate su objektų savybėmis. Tačiau naudodami `const` galite pagerinti kodo skaitomumą ir išvengti netyčinių duomenų pakeitimų.
	    
	-   **Pirmenybę teikite `let` vietoj `var`**: `let` geriau tinka bloko lygio srityje (_block-level scoping_) ir suteikia daugiau nuspėjamumo kode.
	    
	-   **Inicializuokite deklaravimo metu**: Nors TypeScript leidžia inicializuoti po deklaracijos, geriausia praktika yra deklaruoti ir inicializuoti kintamuosius tuo pačiu metu, siekiant pagerinti kodo aiškumą ir tipų saugumą.
	    
	-   **Pirmenybę teikite tipų anotacijoms**: Aiškiai nurodant kintamųjų tipus galima pagerinti kodo skaitomumą. Tačiau kai kintamojo tipas akivaizdus iš inicializacijos, pakanka tipų išvedimo (_type inference_).

5. Kas yra TypeScript sąsajos (Interfaces) ir kaip jos veikia?

	TypeScript sąsajos apibrėžia savo narių struktūrą ir tipus. Jos veikia kaip sutartis dėl reikalaujamų savybių ir metodų, užtikrindamos, kad jas įgyvendinančios klasės arba objektai atitiktų šią struktūrą.

	#### Sąsajų pagrindinės savybės

	-   **Tipų nuoseklumas**: Objektai, kurie laikosi sąsajos (`interface`) struktūros, yra suderinami (_compatable_) su ja.
	-   **Pasirinktini ir tik skaitymo nariai**: Sąsajos (_interfaces_) leidžia naudoti pasirinktines savybes (_optional attributes_) ir tik skaitymo narius (_readonly members_) su `?` ir `readonly` raktiniais žodžiais.
	-   **Iškvietimo prierašai (Call Signatures)**: Sąsajos (_interfaces_) gali apibrėžti metodų tipus, nurodydamos funkcijų parametrų ir grąžinimo tipus.
	-   **Indekso prierašai (Index Signatures)**: Naudingi nortint nurodyti, kad objektas gali turėti bet kokį skaičių savybių, iš jų visos turi tą patį tipą.

	#### Pagrindiniai naudojimo atvejai

	-   **Objektų standartizavimas**: Užtikrina, kad įvairūs objektai turėtų bendrą struktūrą, kad būtų lengviau naudotis (_ease of use_) ir padidėtų suderinamumas (_cohesiveness_).
	-   **Sutarties vykdymas (_Contract Enforcement_)**: Priverčia klases atitikti tam tikrus savybių ir metodų reikalavimus, taip sumažindamas klaidų tikimybę ir gerindamas palaikomumą (_maintainability_).

	#### Kodo pavyzdys: pagrindinė sąsaja (`interface`)

	Čia pateiktas TypeScript kodas:

	```ts
	interface Point {
	    x: number;
	    y: number;
	}
	  
	function printPoint(p: Point) {
	    console.log(`Point coordinates: (${p.x}, ${p.y})`);
	}

	let pointA = { x: 3, y: 7 }; // This object matches Point's structure
	let pointB = { x: 8 }; // This object is missing the 'y' property

	printPoint(pointA); // Output: Point coordinates: (3, 7)
	printPoint(pointB); // Compile-time error due to incorrect structure
	```

6. Apibūdinkite `enum` tipą ir kada jį reikėtų naudoti.

	`enum` yra duomenų tipas, kuris supaprastina diskrečiai pavadintų reikšmių atvaizdavimą ir valdymą. Tai esminis įrankis užtikrinant tipų saugumą TypeScript. `enum ` tipo naudojimo, situacijų pavyzdžiai:

	-   **„Magiškų reikšmių (_Magic Values_)“ mažinimas**: Padeda užtikrinti skaitomumą ir išvengti pasikartojančių tiesioginių (_literal_) reikšmių, tokių kaip `1`, `2` ar `'red'`.
	-   **Elgsenos konfigūravimas**: Naudojamas susijusių reikšmių (_associated values_) rinkiniams, tokiems kaip HTTP metodai, užsakymų ar klientų tipai (_ordering or customer types_), konfigūruoti.
	-   **Tipų saugumas ir efektyvumas**: Iš anksto apibrėžtas galiojančių (_valid_) narių rinkinys ir aiškus duomenų tipas užtikrina, kad reikšmių priskyrimas ir operacijos būtų vienareikšmiškos ir nuoseklios (_unequivocal and consistent_).

	#### Pagrindinės sudedamosios dalys

	-   **Raktas (_Key_)**: Unikalus identifikatorius, paprastai skaičius arba eilutė.
	-   **Reikšmė (_Value_)**: Duomenys, susieti su raktu (_key_). Jei reikšmė nenurodyta, naudojamas raktas.

	#### Standartiniai, eilučių (_string_) ir nevienalyčiai (_heterogeneous_) `enum` tipai

	-   **Standartis `enum` tipas**: Visi raktai ir reikšmės yra to paties duomenų tipo, paprastai skaičiai.
	-   **Eilučių (_string_) `enum` tipas**: Visi raktai ir reikšmės turi būti eilutės, užtikrinant nuoseklų duomenų atvaizdavimą.
	-   **Nevienalytis (_Heterogeneous_) `enum` tipas**: Apibrėžia raktus tiek su skaičiais, tiek su eilutėmis (_string_). Dėl mišraus tipo pobūdžio šio `enum` būdo, dažniausiai reikėtų vengti.

	#### Kodo pavyzdys: Standartinis `enum` tipas 

	TypeScript kodas:

	```ts
	enum HttpMethods {
	  GET,
	  POST,
	  PUT,
	  DELETE
	}

	const requestType: HttpMethods = HttpMethods.GET;

	// ❌ This is not allowed due to type safety
	// const requestType2: HttpMethods = 'GET';
	```

	Šiame pavyzdyje raktui `GET`, netiesiogiai (_implicitly_) priskiriama reikšmė  `0`.

	#### Kodo pavyzdys: Eilučių (_string_) `enum` tipas

	TypeScript kodas:

	```ts
	enum MediaTypes {
	  Image = 'image',
	  Video = 'video',
	  Audio = 'audio'
	}

	const selectedType: MediaTypes = MediaTypes.Image;

	// ❌ This is not allowed due to type safety
	// const selectedType2: MediaTypes = MediaTypes.Video;

	// ✅ Accessing the value
	const associatedText: string = MediaTypes.Image;

	// ❌ This is not allowed due to type safety
	// const invalidType: MediaTypes = 'image';
	```

	`enum` tipas padeda užtikrinti tinkamą duomenų tipą ir jo reikšmes.
	
	#### Pragmatiškas `enum` tipo naudojimas

	Nors `enum` tipas yra galingas įrankis tipų saugumui palaikyti, jis supaprastina susijusių reikšmių rinkinių asocijavimą.

	Tačiau reikia atsižvelgti į tai, kad `enum` tipo reikšmė gali būti išvesta (_inferred_) arba priversta būti, bet kokio rakto ir pagrindinės reikšmės tipu.

	#### Galimi `enum` tipo trūkumai

	-   **Kompiliacijos įtaka**: Naudojant platesniame kontekste (_broader context_) ar duomenų struktūrose, tokiose kaip masyvai ar _Map_, TypeScript generuoja papildomą kodą, kad konvertuotų `enum` raktus (_keys_) į susijusias reikšmes (_values_).
	-   **Atminties naudojimas**: Kiekvienam `enum` tipo naudojimui reikalingas atminties paskirstymas (_memory allocation_), jo reikšmei.

	Kai paprasta konstanta (`const`) būtų pakankama arba jei reikia dinamiškesnių ryšių tarp raktų (_keys_) ir reikšmių (_values_), detalesni tipai yra geresnė alternatyva `enum` tipui.

7. Kaip apibūdinti ir naudoti funkciją TypeScript kalboje?

	Apibūdinant funkciją TypeScript kalboje, reikia atsižvelgti į šiuos pagrindinius komponentus:

	-   **Funkcijos prierašas (_Function Signature_)**: Apima funkcijos pavadinimą, parametrų sąrašą, tipą ir grąžinimo (_return_) reikšmę.
	-   **Funkcijos kūnas (_Function Body_)**: Sudaro faktinę operaciją arba veiksmų seką, kurią atliks funkcija.

	#### Pagrindinės sąvokos

	1.  **Funkcijos deklaracija (_Function Declaration_)**

	Norėdami deklaruoti funkciją, nurodote jos pavadinimą, parametrų sąrašą ir grąžinimo tipą. Jei funkcija negrąžina reikšmės, nustatote grąžinimo tipą į `void`.

	Štai kodo pavyzdys:

	```ts
	function greet(name: string): void {
	    console.log(`Hello, ${name}!`);
	}
	```

	2.  **Funkcijos išraiška (_Function Expression_)**

	Taip pat galite deklaruoti funkcijas naudodami išraiškas, kuriose funkcijos priskiriamos kintamiesiems kaip reikšmės. Šis būdas suteikia daugiau lankstumo, pvz., kai naudojate `callback` funkcijas.

	Štai pavyzdys:

	```ts
	let greet: (name: string) => void;
	greet = function(name: string): void {
	    console.log(`Hello, ${name}!`);
	};
	```

	3.  **Pasirinktiniai ir numatytieji parametrai (_Optional and Default Parameters_)**

	TypeScript palaiko pasirenkamuosius (_optional_) ir numatytuosius (_default_) funkcijų parametrus, padidindamas funkcijų lankstumą.

	**Pasirinktiniai (_optional_) parametrai** žymimi `?` simboliu po parametro pavadinimo.

	Štai kodo pavyzdys:

	```ts
	function greet(name: string, title?: string) {
	    if (title) {
	        console.log(`Hello, ${title} ${name}!`);
	    } else {
	        console.log(`Hello, ${name}!`);
	    }
	}
	```

	**Numatytieji (_default_) parametrai** yra tada, kai priskiriate parametro numatytąją reikšmę:

	Štai kodo pavyzdys:

	```ts
	function greet(name = "Stranger") {
	    console.log(`Hello, ${name}!`);
	}
	```

	4.  **_Rest_ parametrai**

	Galite apibrėžti parametrą kaip „rest“ parametrą, o tai reiškia, kad funkcija gali priimti bet kokį skaičių argumentų tam parametrui.

	Štai kodo pavyzdys:

	```ts
	function introduce(greeting: string, ...names: string[]) {
	    console.log(`${greeting}, ${names.join(", ")}!`);
	}

	introduce("Hello", "Alice", "Bob", "Carol");
	```

	5.  **Funkcijų perkrovos (_Function Overloads_)**

	Galite deklaruoti kelias funkcijos perkrovas (_overloads_), kad apibrėžtumėte parametrų rinkinį ir jų grąžinimo (_return_) tipus vienai funkcijai. Ši savybė (_feature_) ypač naudinga, kai funkcijos elgesys logiškai keičiasi priklausomai nuo skirtingų įvesties tipų.

	Štai kodo pavyzdys:

	```ts
	function specialGreet(name: string): void;
	function specialGreet(title: string, name: string): void;

	function specialGreet(a: any, b?: any): void {
	    if (b) {
	        console.log(`Hello, ${a}, ${b}`);
	    } else {
	        console.log(`Hello, ${a}`);
	    }
	}
	```
	
	6.  **Iškvietimo prierašas (_Call Signature_)**

	Naudojant TypeScript objektus, iškvietimo prierašas (_call signature_) naudojamas norint apibrėžti tikėtiną funkcijos struktūrą tam tikram objekto metodui.

	Štai kodo pavyzdys:

	```ts
	type Greeter = {
	    (name: string): void
	};

	let welcome: Greeter;
	welcome = function(name: string): void {
	    console.log(`Welcome, ${name}!`);
	};
	```

8. Ką TypeScript kontekste reiškia „tipų išvedimas (_type inference_)“?

	TypeScript kontekste „tipų išvedimas“ yra pagrindinė savybė (_core feature_), leidžianti automatiškai nustatyti kintamojo tipą pagal jo reikšmę. Tai suteikia statinio tipavimo privalumus be būtinybės aiškiai nurodyti tipus (_explicit type annotations_).

	#### Kaip tai veikia

	TypeScript naudoja geriausio bendro tipo (_best common type_) algoritmą, kad nustatytų kintamojo tipą. Kai TypeScript susiduria su keliais kintamojo tipais priskyrimo metu arba masyvo _literal'e_ (_array literal_), jis apskaičiuoja šių tipų sąjungą (_union_) ir pasirenka geriausią bendrą tipą (_best common type_) kintamajam.

	#### Kodo pavyzdys: Tipų išvedimas (_type inference_)

	Apsvarstykite šį kodą:

	```ts
	let value = 10; // Type 'number' inferred
	let message = "Hello, TypeScript!"; // Type 'string' inferred

	function add(a: number, b: number) {
	    return a + b;
	}

	let sum = add(5, 7); // Type 'number' inferred
	```

	TypeScript gali išvesti (_infer_) labiausiai tikėtiną tipą iš konteksto, pvz.:

	-   Kai reikšmė priskiriama iš karto, TypeScript priskiria kintamajam reikšmės tipą.
	-   Tipo informacija iš gretimų tipų naudojama geriausio bendro tipo (_best common type_) nustatymui. Jei visos reikšmės yra suderinamo (_compatible_) tipo, tas tipas ir yra naudojamas.

	#### Tipų išvedimo (_Type Inference_) privalumai

	-   **Trumpumas (_Conciseness_)**: Pašalina poreikį aiškiai nurodyti tipų deklaracijas (_explicit type declarations_), todėl kodas tampa glaustesnis ir skaitomesnis.
	-   **Pritaikomumas (_Adaptability_)**: Kodų bazės tipai (_Codebase types_) natūraliai suderinami su reikšmėmis, todėl lengviau prižiūrėti kodą, kai keičiasi reikšmės.
	-   **Klaidų sumažinimas**: Sumažina nesuderinamumo (_inconsistencies_) tarp deklaruoto tipo ir faktinės reikšmės riziką.

9. Paaiškinkite `let` ir `const` naudojimą TypeScript kalboje

	TypeScript kalboje `const` ir `let` yra naudojami kintamųjų deklaravimui. Šie du raktiniai žodžiai suteikia aiškumo, srities valdymo galibybę (_scoping_) ir nekintamumo galimybę (_immutability_), padedančius efektyviau valdyti kodą.

	#### Pagrindiniai skirtumai

	-   `const`: Naudojamas konstantoms, kurios išlieka nepakitusios po deklaravimo. Svarbu atkreipti dėmesį, kad tai daro nuorodą (_reference_) nekintamą (_immutable_), tačiau nesustabdoma vidinės būsenos (_internal state_) keitimo sudėtinguose objektuose, pavyzdžiui, masyvuose.
	    
	-   `let`: Naudojamas kintamiesiems su įprastu kintamumo (_mutable_) elgesiu inicijuoti.

	#### Kodo pavyzdys: `const`

	TypeScript kodas:
	
	```ts
	const productId: number = 5;
	let productName: string = 'Tesla';

	const getProductDetails = (id: number): string => {
	  return `Product ID: ${id}`;
	};

	// Attempting to modify will result in a compilation error
	// productId = 6;

	// Reference is still immutable
	const anotherProductId: number = 10;
	// This will throw a compilation error since it's a constant
	// anotherProductId = 12;

	// Modifying internal state of an object is allowed for a const
	const myArray: number[] = [1, 2, 3];
	myArray.push(4);
	```

	#### Kodo pavyzdys: `let`

	TypeScript kodas:

	```ts
	let vehicleType: string = 'Car';

	if (true) {
	  let vehicleType: string = 'Motorcycle';
	  console.log(vehicleType);  // Output: Motorcycle
	}

	console.log(vehicleType);  // Output: Car
	```

10. Kaip kompiliuoti TypeScript failus į JavaScript failus?

	Norint kompiliuoti TypeScript (.ts) failus į JavaScript (.js) failus reikia naudoti TypeScript kompiliatorių (tsc). Galima pertvarkyti (_customize_) kompiliavimo procesą naudojant `tsconfig.json` ir net naudoti pažangesnius metodus, siekiant patenkinti projekto poreikius:

	#### Darbo eigos žingsniai

	1.  **Failų kūrimas (_File Creation_)**: Parašykite TypeScript failus (.ts).
	2.  **Kompiliatoriaus konfigūracija (_Compiler Config_)**: Nustatykite `tsconfig.json` failą su kompiliavimo parinktimis.
	3.  **Kompiliavimas (_Compile_)**: Vykdykite `tsc` komandą, kad pradėtumėte kompiliavimo procesą.
	4.  **Rezultatų patikrinimas (_Output Verification_)**: Peržiūrėkite sugeneruotus JavaScript failus.

	#### TypeScript konfigūracija (`tsconfig.json`)

	Štai `tsconfig.json` failas. Pilną konfigūracijos gidą rasite [čia](https://www.typescriptlang.org/tsconfig).

	```json
	{
	  "compilerOptions": {
	    "target": "ES5",
	    "module": "commonjs",
	    "strict": true,    
	    "outDir": "dist",
	    "rootDir": "src"  
	  },
	  "include": [
	    "src/**/*.ts"    
	  ],
	  "exclude": [      
	    "node_modules",   
	    "**/*.spec.ts"    
	  ]
	}
	```

	#### Praktinis pavyzdys: Vynuogynų gyvenamųjų užduočių valdymo programa

	Štai praktinis ir išsamus `tsconfig.json` failas.

	```json
	{
	  "compilerOptions": {
	    "target": "es5",
	    "module": "commonjs",
	    "lib": ["dom", "es2015", "es5", "es6", "es7", "es2015.collection"],
	    "allowJs": true,
	    "checkJs": false,
	    "jsx": "react",
	    "declaration": false,
	    "sourceMap": true,
	    "outDir": "dist",  
	    "rootDir": "src",
	    "strict": true,
	    "noImplicitAny": true,
	    "noImplicitThis": true,
	    "moduleResolution": "node",
	    "esModuleInterop": true,
	    "forceConsistentCasingInFileNames": true,
	    "removeComments": true,
	    "suppressImplicitAnyIndexErrors": true,
	    "typeRoots": ["node_modules/@types", "custom-typings"],
	    "baseUrl": ".",
	    "paths": {
	      "components/*": ["src/components/*"],
	      "utils/*": ["src/utils/*"],
	    },
	    "experimentalDecorators": true,
	    "emitDecoratorMetadata": true,
	    "incremental": true,
	    "diagnostics": true,
	    "resolveJsonModule": true,
	    "isolatedModules": true,
	    "newLine": "LF",
	    "watchOptions": {
	      "watchFile": "useFsEvents",  
	      "fallbackPolling": "dynamicPriority",   
	      "polling": true,
	      "esModuleInterop": true,
	            "pollingInterval": 2500,
	      
	      "followSymlinks": true
	    }
	  },
	  "include": [
	    "src/**/*.ts",
	    "src/**/*.tsx",
	    "@types"
	  ],
	  "exclude": [
	    "node_modules",
	    "dist"
	  ]
	}
	```

	#### Pažangios konfigūracijos

	-   **Projekto nuorodos (_Project Reference_)**: Naudinga kodo padalijimui dideliuose projektuose.
	-   **Individualūs transformatoriai (_Custom Transformers_)**: Naudokite individualią logiką kompiliavimo proceso metu.
	-   **Programinis API (_Programmatic API_)**: Suteikia lankstumo valdant kompiliatoriaus nustatymus ir vykdymą.

11. Paaiškinkite TypeScript klases. Kuo jos skiriasi nuo ES6 klasių?

	Nors TypeScript ir ES6 klasės turi daug panašumų, TypeScript klasės siūlo papildomas savybes ir stiprų tipavimą, kad kodas būtų tvaresnis (_robust_).

	#### Pagrindinės _shared_ klasės savybės

	-   **Paveldimumas (_Inheritance_)**: Poklasės (vaikinės klasės) gali paveldėti tėvinių klasių metodus ir savybes.
	-   **Polimorfizmas (_Polymorphism_)**: Išvestinės (_derived_) klasės gali apibrėžti metodus tokiu pačiu pavadinimu kaip ir jų tėvinės klasės.
	-   **Kapsuliavimas (_Encapsulation_)**: Duomenų slėpimas palaikomas naudojant prieigos modifikatorius, tokius kaip `public`, `private` ir `protected`.
	-   **Konstruktorius (_Constructor_)**: Instancijos kūrimas (_instantiation_) prasideda nuo konstruktoriaus metodo, jei jis apibrėžtas.

	#### Unikalios TypeScript klasių savybės

	**Laukų deklaracija (_Field Declaration_)**

	TypeScript leidžia nurodyti laukus tiesiogiai klasėje be jų inicializavimo. Objekto kūrimo metu laukai automatiškai inicializuojami kaip `undefined`. ES6 reikalauja, kad laukai būtų inicializuojami konstruktoriuje arba jų deklaracijoje.

	```ts
	class Example {
	   // Field is automatically initialized to undefined upon object creation
	   someField: string;
	}
	```

	**Abstrakčios klasės (_Abstract Classes_)**

	TypeScript palaiko abstrakčias klases, kurios veikia kaip šablonas kitoms klasėms. Jos negali būti "aktyvuojamos" (_instantiated_), bet gali suteikti tam tikrą įgyvendinimą (_implementation_), kurį išvestinės (_derived_) klasės gali perrašyti.

	```ts
	abstract class AbstractExample {
	    abstract someMethod(): void;  // Method has no implementation (abstract)
	}
	```

	**Readonly savybės (_Readonly Properties_)**

	Galima nurodyti klasės savybes _class properties_, kaip `readonly`, užtikrinant, kad jos bus nustatytos tik deklaravimo metu (_set upon declaration_) arba klasės konstruktoriuje.

	```ts
	class Example {
	    readonly id: number;
	    constructor(id: number) {
	        this.id = id;  // Readonly can only be assigned in the constructor or declaration
	    }
	}
	```

	**Statiniai nariai (_Static Members_)**

	TypeScript klasės palaiko statinius narius, tokius kaip savybės ir metodai (_properties and methods_), kurie priklauso pačiai klasei, o ne jos instancijoms (_instances_).

	```ts
	class Example {
	    static count = 0;  // Static property
	    static incrementCount() {
	        Example.count++;
	    }
	}
	```

	**Accessor funkcijos (_Accessor Functions_)**

	Galima apibrėžti get ir set funkcijas TypeScript klasėse, kitaip žinomas kaip aksesorių funkcijas, norint valdyti, kaip klasės savybės (_properties_) yra pasiekiamos ir modifikuojamos.

	```ts
	class Example {
	    private _name: string;

	    get name(): string {
	        return this._name;
	    }

	    set name(newName: string) {
	        this._name = newName.trim();
	    }
	}
	```

	**Parametrų savybės (_Parameter Properties_)**

	TypeScript siūlo _shortcut_'ą deklaruoti savybę ir inicializuoti ją iš konstruktoriaus parametro. Šis metodas gali padaryti kodą glaustesnį, ypač kai konstruktoriaus parametras tiesiogiai atitinka klasės savybę.

	```ts
	class Example {
	    constructor(private _name: string, public age: number) {
	        // Private _name property created and initialized from constructor parameter
	        // Public age property created and initialized from constructor parameter
	    }
	}
	```

	**Klasės susikirtimų tipai (_Intersection Types_)**

	TypeScript kalboje, kai apibrėžiate bazinę klasę ir vėliau ją išplečiate (_extend_), sukuriate susikirtimų tipą. Tai reiškia, kad vaikinė klasė paveldės visas savybes ir metodus tiek iš tėvinės klasės, tiek iš pačios savęs.

	#### ES6 savybės, kurių neturi TypeScript

	**Klasės išraiškos (_Class Expressions_)**

	Tiek ES6, tiek TypeScript palaiko klasių išraiškas, leidžiančias apibrėžti klasę, be klasės pavadinimo.

	ES6 pavyzdys:

	```js
	const Animal = class {
	    // Class methods and properties defined here
	};
	```

	**Iteratoriaus protokolas (_Iterator Protocol_)**

	ES6 klasės palaiko iteratoriaus protokolą, todėl yra lengviau peržiūrėti objektus.

	```js
	class IterableExample implements Iterable<string> {
	    // Implement iterator function for strings
	    [Symbol.iterator]() {
	        let index = 0;
	        const data = ['one', 'two', 'three'];
	        return {
	            next: () => {
	                if (index < data.length) {
	                    return { value: data[index++], done: false };
	                }
	                return { value: undefined, done: true };
	            }
	        };
	    }
	}
	```

12. Kaip įgyvendinti (_implement_) paveldimumą (_Inheritance_) TypeScript kode?
	
	 Paveldimumą (_Inheritance_) TypeScript kode galima įgyvendinti (_implement_), naudojant tiek ES6 klases, tiek prototipinį paveldėjimą.

	#### 1. Paveldimumas su ES6 klasių sintakse

	Su ES6 atsiradimu buvo įvesta pažįstamesnė, klasėmis pagrįsta, paveldėjimo metodika. Ši metodika, paprastai, yra lengviau skaitoma ir suprantama. 

	##### Kodo pavyzdys: Paveldimumas naudojant ES6 klases

	TypeScript kodas:

	```ts
	class Animal {
	  private name: string;

	  constructor(theName: string) {
	    this.name = theName;
	  }

	  move(distanceInMeters: number = 0) {
	    console.log(`${this.name} moved ${distanceInMeters}m.`);
	  }
	}

	class Snake extends Animal {
	  constructor(name: string) {
	    super(name);
	  }

	  move(distanceInMeters = 5) {
	    console.log("Slithering...");
	    super.move(distanceInMeters);
	  }
	}

	const mySnake = new Snake("Cobra");
	mySnake.move();  // Output: Slithering... Cobra moved 5m.
	```

	#### 2. Paveldimumas su prototipine metodologija (_Prototypal Methodology_)

	Prieš ES6, TypeScript programavimo kalba, kaip ir JavaScript, naudojo prototipinį paveldimumą.

	Prototipinė metodika (_Prototypal Methodology_) gali būti naudinga kuriant sudėtingas objektų struktūras, tačiau svarbu atkreipti dėmesį į detales, kad būtų išvengta netikėto elgesio (_unexpected behavior_). 

	##### Kodo pavyzdys: Prototipinis paveldimumas TypeScript programavimo kalboje.

	TypeScript kodas:

	```ts
	// Define the Parent Class
	function Animal(this: Animal, name: string) {
	  this.name = name;
	}

	Animal.prototype.move = function(distanceInMeters: number = 0) {
	  console.log(`${this.name} moved ${distanceInMeters}m.`);
	};

	// Define the Child Class
	function Snake(name: string) {
	  Animal.call(this, name);
	}

	// Set up the Inheritance
	Snake.prototype = Object.create(Animal.prototype);
	Snake.prototype.constructor = Snake;

	// Override the Base Type's Method
	Snake.prototype.move = function(distanceInMeters = 5) {
	  console.log("Slithering...");
	  Animal.prototype.move.call(this, distanceInMeters);
	};

	const mySnake = new Snake("Cobra");
	mySnake.move();  // Output: Slithering... Cobra moved 5m.
	```

	#### Supaprastinti metodai
	
	Naudoti prototipinę konstrukciją (_prototypal construct_) iš pradžių gali būti sudėtinga, tačiau jos stiprybė yra lankstume.

	Galite išvengti tiesioginių prototipo priskyrimų sudėtingumo, naudodami ES5 išvestines konstrukcijas (_ES5 derived constructions_), kaip parodyta toliau:

	```ts
	function Animal(name: string) {
	  this.name = name;
	}

	Animal.prototype.move = function(distanceInMeters: number = 0) {
	  console.log(`${this.name} moved ${distanceInMeters}m.`);
	};

	function Snake(name: string) {
	  Animal.call(this, name);
	}

	// Utilize `Object.create` for simplified prototype delegation
	Snake.prototype = Object.create(Animal.prototype);
	Snake.prototype.constructor = Snake;

	Snake.prototype.move = function(distanceInMeters = 5) {
	  console.log("Slithering...");
	  Animal.prototype.move.call(this, distanceInMeters);
	};
	```

13. Kas yra prieigos modifikatoriai (_access modifiers_) ir kaip jie veikia TypeScript kalboje?

	Prieigos modifikatoriai (_access modifiers_) yra TypeScript būdas kontroliuoti klasės narių matomumą ir keičiamumą (_visibility and mutability_). Jie užtikrina kapsuliavimą (_encapsulation_) ir yra ypač naudingi objektiniam (_object-oriented_) dizainui. 

	#### Pagrindiniai modifikatoriai

	-   **Public**: Numatytoji klasės narių būsena. Ji yra pasiekiama tiek klasės viduje, tiek išorėje.
	    
	-   **Protected**: Nariai gali būti pasiekiami klasės ir jos poklasių viduje. Jie padeda nustatyti "_is-a_" (yra) santykį.
	    
	-   **Private**: Žymi narius, kaip pasiekiamus tik deklaruojančioje klasėje. Tai užtikrina, kad jie nebūtų modifikuojami ar pasiekiami (_modified or accessed_) iš išorės.
	    

	##### Kodo pavyzdys: Prieigos modifikatorių (_access modifiers_) veikimas

	Štai TypeScript kodas:

	```ts
	class Person {
	    public name: string;
	    private age: number;
	    protected contact: string;

	    constructor(name: string, age: number, contact: string) {
	        this.name = name;
	        this.age = age;
	        this.contact = contact;
	    }
	}

	class Employee extends Person {
	    private employeeId: string;

	    constructor(name: string, age: number, contact: string, employeeId: string) {
	        super(name, age, contact);
	        this.employeeId = employeeId;
	    }

	    public displayDetails(): void {
	        console.log(`${this.name} - ${this.age} - ${this.contact} - ${this.employeeId}`);
	    }
	}

	// Somewhere in your code
	const person = new Person("John Doe", 30, "1234567");
	console.log(person.name);  // Accessible
	console.log(person.age);   // ERROR: 'age' is private

	const employee = new Employee("Jane Doe", 25, "2345678", "E123");
	console.log(employee.contact);  // ERROR: 'contact' is protected
	employee.displayDetails();     // Correctly displays details

	employee.age = 35;    // ERROR: 'age' is private
	employee.contact = "3456789";  // ERROR: 'contact' is protected
	```

14. Apibūdinkite abstrakčias klases (_Abstract classes_) ir jų prasmę TypeScript kalboje.

	TypeScript abstrakčios klasės (_Abstract classes_) veikia kaip planai, kurie nurodo paveldėtoms klasėms, kaip struktūrizuoti kodą, tačiau nebūtinai pateikia visų metodų įgyvendinimus (_implementations_).

	#### Pagrindinės abstrakčių klasių (_Abstract classes_) savybės

	##### Metodų parašai (_Method Signatures_)

	Abstrakčios klasės (_Abstract classes_) apibrėžia metodų parašus be funkcionalumo tikslinimo. Ši funkcija suteikia išvestinėms (_derived_) klasėms aiškų planą, nuo kurio galima pradėti. 

	##### Konkretūs metodų apibrėžimai (_Specific Method Definitions_)

	Be metodų parašų, abstrakčios klasės (_Abstract classes_) gali turėti visiškai įgyvendintus (_completely implemented_) metodus. Šie metodai arba palaiko abstrakčius metodus (_abstract methods_), arba veikia kaip nepriklausomos funkcijos. 

	##### Abstrakčių ir neabstrakčių narių atskyrimas (_Abstract and Non-Abstract Members Separation_)

	Abstrakčios klasės (_Abstract classes_) aiškiai nurodo, kurie metodai turi būti įgyvendinti išvestinėse (_derived_) klasėse, ir kurie metodai yra visiškai įgyvendinti (_fully implemented_) arba neprivalomi (_optional_).

	#### Dažniausi abstrakčių (_Abstract classes_) klasių naudojimo atvejai

	-   **Skatina pakartotinį naudojimą**: Abstrakčios klasės (_Abstract classes_) padeda sujungti bendras ar bendrinamas (_common or shared_) funkcijas tarp kelių išvestinių (_derived_) klasių.
	-   **Sutarties įgyvendinimas (_Contract Enforcement_)**: Jos užtikrina, kad išvestinės (_derived_) klasės laikytųsi bendros struktūros, garantuojant, kad būtų įgyvendintas tam tikras metodų rinkinys (_set of methods_).
	-   **Dalinis įgyvendinimai**: Abstrakčios klasės (_Abstract classes_) leidžia derinti visiškai įgyvendintus metodus (_fully implemented_) su tais, kurie reikalauja konkrečių įgyvendinimų (_implementations_) išvestinėse (_derived_) klasėse.

	#### TypeScript _Utility_: Statinės savybės (_Static Properties_)

	TypeScript abstrakčios klasės (_Abstract classes_) gali turėti statines savybes (_Static Properties_), kurios priklauso pačiai klasei, o ne konkrečiai jos instancijai (_instance_). Ši funkcija suteikia patogų būdą apibrėžti savybes ar metodus, prieinamus be klasės instancijos (_instance_) sukūrimo.

	##### Kodo pavyzdys: Abstrakti klasė

	Štai TypeScript kodas:

	```ts
	abstract class Shape {
	    abstract getArea(): number;
	    abstract getPerimeter(): number;
	    color: string;

	    constructor(color: string) {
	        this.color = color;
	    }

	    static defaultColor: string = 'red';

	    describe() {
	        return `This shape is ${this.color}.`;
	    }
	}

	// This will throw an error because the derived class does not provide concrete implementations for abstract methods.
	class Circle extends Shape { 
	    constructor(public radius: number, color: string) {
	        super(color);
	    }

	    // The 'Circle' class inherited the following properties from 'Shape', but neither implements nor specifies them in the derived class: 'getArea' and 'getPerimeter'.
	    getArea(): number {
	        return Math.PI * this.radius ** 2;
	    }

	    getPerimeter(): number {
	        return 2 * Math.PI * this.radius;
	    }
	}

	const myCircle = new Circle(5, 'blue');
	console.log(myCircle.getArea()); // Outputs: 78.54
	console.log(myCircle.describe()); // Outputs: This shape is blue.
	console.log(Shape.defaultColor); // Outputs: red
	```
	
15. Ar galite apibūdinti konstruktorių naudojimą TypeScript klasėse?

	TypeScript suteikia patogų būdą apibrėžti konstruktorius klasėms, naudojant `constructor` raktažodį. Konstruktoriaus metodas leidžia inicijuoti klasės narius ir gali turėti prieigos specifikatorius (_access specifiers_). Jie yra naudingi nustatant objekto pradinę būseną (_initial state_).

	#### Pagrindinės savybės

	-   **Automatinis iškvietimas (_Automatic Invocation_)**: Konstruktorius automatiškai iškviečiamas, kai sukuriamas klasės objektas.
	-   **Vienintelis unikalus konstruktorius (_Single Unique Constructor_)**: Klasė gali turėti tik vieną konstruktorių, kuris suteikia centralizuotą vietą inicializavimui.
	-   **Perkrovos galimybės (_Overload Capabilities_)**: Galite perkrauti (_overload_) konstruktorių, kad apibrėžtumėte kelis objekto inicializavimo būdus.

	##### Pavyzdys: Konstruktorius TypeScript

	Naudojame `this` raktažodį, kad nurodytume dabartinė instanciją (_instance_), užtikrindami teisingą duomenų priskyrimą (_data assignment_).

	```ts
	class Person {
	  // Member variables
	  name: string;
	  age: number;
	  
	  // Constructor
	  constructor(name: string, age: number) {
	    this.name = name;
	    this.age = age;
	  }
	}
	```

	#### Konstruktoriaus prieigos modifikatoriai (_Access Modifiers_)

	TypeScript palaiko prieigos modifikatorius konstruktoriaus parametruose, leidžiančius glaustai ir saugiai inicijuoti klasę.

	-   **Vieša (_Public_)**: Parametrai be modifikatoriaus pagal numatytuosius nustatymus yra vieši.
	-   **Privati (_Private_)**: Pridedant `private` raktažodį, jie tampa prieinami tik klasės viduje.
	-   **Tik skaitymui (_Read-Only_)**: Derinant `readonly` su parametru ir `private` arba `public` prieigos modifikatoriumi, užtikrinama, kad parametras būtų priskirtas tik vieną kartą, konstruktoriaus viduje.


### Šaltiniai:

- https://github.com/Devinterview-io/typescript-interview-questions?tab=readme-ov-file

 - 100 klausimų versija: https://devinterview.io/questions/web-and-mobile-development/typescript-interview-questions/
