---
---

<h2 id="react-ekostistema-jsx-sintaksė-ir-state-valdymas">1. React ekostistema, JSX sintaksė ir state valdymas</h2>
<h3 id="react-įvadas"><strong>1. React Įvadas</strong></h3>
<p><strong>Kas yra React?</strong></p>
<ul>
  <li>
    <strong>Kilmė</strong>: React yra JavaScript biblioteka, kurią sukūrė Facebook inžinieriai. Ji skirta kurti
    interaktyvias vartotojo sąsajas.
  </li>
  <li>
    <strong>Kodėl ji yra populiari?</strong>: Dėl jos efektyvumo, komponentinio struktūros ir didelės bendruomenės.
  </li>
</ul>
<p><strong>React vs. tradiciniai puslapiai</strong></p>
<ul>
  <li>
    <p>
      <strong>Declarative UI</strong>: Palyginimui, tradicinis JavaScript dažnai reikalauja rašyti daugiau kodo, kad
      atvaizduotų UI pakeitimus.
    </p>
    <pre><code>// Tradicinis JavaScript: Imperatyvus UI pavyzdys
const button = document.createElement('button');
button.innerText = 'Spustelėk mane';
button.onclick = function() {
  alert('Paspausta!');
};
document.body.appendChild(button);

// React: Deklaratyvus UI pavyzdys
function App() {
  return &lt;button onClick={() =&gt; alert('Paspausta!')}&gt;Spustelėk mane&lt;/button&gt;;
}
</code></pre>
  </li>
</ul>
<hr />
<h3 id="jsx-sintaksė"><strong>2. JSX Sintaksė</strong></h3>
<p><strong>JSX Pristatymas</strong></p>
<ul>
  <li>
    <strong>Apibrėžimas</strong>: JSX yra sintaksė, naudojama React aplikacijose, kad būtų galima rašyti HTML elementus
    naudojant JavaScript.
  </li>
</ul>
<p><strong>JSX vs. HTML</strong></p>
<ul>
  <li>
    <p><strong>Skirtumai</strong>: JSX leidžia įterpti JavaScript išraiškas naudojant <code>{}</code>.</p>
    <pre><code>// JSX pavyzdys: Komponentas su JavaScript išraiška
function WelcomeMessage({ name }) {
  return &lt;h1&gt;Sveiki, {name}!&lt;/h1&gt;;
}
</code></pre>
  </li>
</ul>
<p><strong>JSX išraiškos</strong></p>
<ul>
  <li>
    <p><strong>Veikimas</strong>: Įterpiant JavaScript kintamuosius ar funkcijas į JSX.</p>
    <pre><code>function NumberList({ numbers }) {
  return (
    &lt;ul&gt;
      {numbers.map((number, index) =&gt; &lt;li key={index}&gt;{number}&lt;/li&gt;)}
    &lt;/ul&gt;
  );
}
</code></pre>
  </li>
</ul>
<hr />
<h3 id="komponentų-kūrimas-reacte"><strong>3. Komponentų kūrimas React’e</strong></h3>
<p><strong>Funkciniai ir klasiniai komponentai</strong></p>
<ul>
  <li>
    <p><strong>Pavyzdys</strong>: Skirtumas tarp funkcinio ir klasinio komponento.</p>
    <pre><code>
// Funkcinis komponentas
function Greeting({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
}

// Klasinis komponentas
class Greeting extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}!&lt;/h1&gt;;
  }
} 
</code></pre>
  </li>
</ul>
<p><strong>Props</strong></p>
<ul>
  <li>
    <p><strong>Pavyzdys</strong>: Duomenų perdavimas iš tėvo komponento.</p>
    <pre><code>// Tėvo komponentas
function Parent() {
  return &lt;Child name="Jonas" /&gt;;
}

// Vaiko komponentas
function Child({ name }) {
  return &lt;h1&gt;Sveiki, {name}!&lt;/h1&gt;;
}
</code></pre>
  </li>
  <li>
    <p>
      <strong>Komponentai su <code>PropTypes</code></strong>
    </p>
    <p>import PropTypes from ‘prop-types’;</p>
    <pre><code>  // Tėvo komponentas
  function ParentComponent() {
    return (
      &lt;div&gt;
        &lt;ChildComponent name="Jonas" age={30} isActive={true} /&gt;
      &lt;/div&gt;
    );
  }

  // Vaiko komponentas
  function ChildComponent({ name, age, isActive }) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Sveiki, {name}!&lt;/h1&gt;
        &lt;p&gt;Amžius: {age}&lt;/p&gt;
        &lt;p&gt;Statusas: {isActive ? "Aktyvus" : "Neaktyvus"}&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  // Nustatome PropTypes vaiko komponentui
  ChildComponent.propTypes = {
    name: PropTypes.string.isRequired, // `name` turi būti eilutės tipo ir yra privalomas
    age: PropTypes.number, // `age` turi būti skaičiaus tipo
    isActive: PropTypes.bool // `isActive` turi būti loginio tipo
  };
</code></pre>
  </li>
</ul>
<hr />
<h3 id="state-būsenos-valdymas-reacte"><strong>4. State (Būsenos) Valdymas React’e</strong></h3>
<p><strong>Kas yra State?</strong></p>
<ul>
  <li>
    <strong>Apibrėžimas</strong>: State yra duomenų rinkinys, kuris kontroliuoja komponento elgseną ir atvaizdavimą.
    State leidžia komponentams reaguoti į įvykius (pvz., vartotojo įvestis, tinklo užklausos) ir atnaujinti UI
    atitinkamai be puslapio perkrovimo.
  </li>
</ul>
<p><strong>Kaip veikia State?</strong></p>
<ul>
  <li><strong>Savybės</strong>: State yra privatus ir pilnai kontroliuojamas paties komponento.</li>
  <li>
    <strong>Atnaujinimas</strong>: State keitimas visada turi vykti naudojant <code>setState()</code> metodą (klasinėse
    komponentose) arba <code>useState()</code> hooksą (funkcinėse komponentose), kuris informuoja React’ą, kad
    komponentas turi būti iš naujo nupieštas su nauja būsena.
  </li>
</ul>
<p><strong>State naudojimo pavyzdys klasiniame komponente</strong></p>
<pre><code>class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () =&gt; {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={this.increment}&gt;Click me&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>
  <strong>State naudojimo pavyzdys funkciniam komponente su hook <code>useState</code></strong>
</p>
<pre><code>import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () =&gt; {
    setCount(count + 1);
  }

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={increment}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>
  <strong>Kodėl svarbu naudoti <code>setState</code> ar <code>useState</code>?</strong>
</p>
<ul>
  <li>
    <strong>Asinchroninis atnaujinimas</strong>: <code>setState()</code> ir <code>useState()</code> užtikrina, kad React
    atnaujintų komponento UI efektyviai ir saugiai. Šie metodai planuoja atnaujinimus, o ne iškart juos įgyvendina,
    leidžiant React optimizuoti UI atnaujinimą.
  </li>
  <li>
    <strong>Būsenos kėlimas</strong>: Kai keli komponentai priklauso nuo tos pačios būsenos, svarbu kelti būseną į
    bendrą tėvą (angl. lifting state up) siekiant užtikrinti duomenų srauto valdymą tarp komponentų.
  </li>
</ul>
<p><strong>Pavyzdys useState hook su input</strong></p>
<pre><code>import { useState } from 'react';

function TextInput() {
  const [value, setValue] = useState('');

  const handleChange = (event) =&gt; {
    setValue(event.target.value);
  }

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={value}
        onChange={handleChange}
      /&gt;
      &lt;p&gt;Įvestas tekstas: {value}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><strong>Sudėtingesnis pavyzdys: Valdymas kelių state</strong></p>
<p>Kartais norime valdyti keletą įvesties laukų, kiekvienas su savo būsena.</p>
<pre><code>import { useState } from 'react';

function MultiInputForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: ''
  });

  const handleChange = (event) =&gt; {
    const { name, value } = event.target;
    setFormData(prevFormData =&gt; ({
      ...prevFormData,
      [name]: value
    }));
  }
  
  const handleSubmit = (event) =&gt; {
	event.preventDefault();
	console.log(formData);
  }

  return (
    &lt;form onSubmit=(handleSubmit)&gt;
      &lt;input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Vartotojo vardas"
      /&gt;
      &lt;input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="El. paštas"
      /&gt;
      &lt;p&gt;Vartotojo vardas: {formData.username}, El. paštas: {formData.email}&lt;/p&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p><strong>Pavyzdys</strong></p>
<pre><code>import { useState } from 'react';

const baseUrl = "https://picsum.photos/300/200?image=";

function Slideshow() {
  const [img, setImg] = useState(0);
  const imgUrl = baseUrl + img.toString();

  function goToPrevImg() {
    setImg(img !== 0 ? img - 1 : 0);
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;Image {img}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setImg(0)}&gt;Start&lt;/button&gt;
      &lt;button onClick={goToPrevImg}&gt;Prev&lt;/button&gt;
      &lt;img src={imgUrl} alt="slideshow" /&gt;
      &lt;button onClick={() =&gt; setImg(img + 1)}&gt;Next&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Slideshow;
</code></pre>
<hr />
<p>
  Pavyzdys: komponento struktūra todo programoje<br />
  <a href="https://postimg.cc/dDdfZhFH"
    ><img src="https://i.postimg.cc/CM6pt8Qg/todo-app-components.png" alt="todo-app-components.png"
  /></a>
</p>
<p>
  Komponenai, state ir props todo programoje<br />
  <a href="https://postimg.cc/HJbgYB6z"
    ><img src="https://i.postimg.cc/d0xt9fdb/todo-app-file-structure.png" alt="todo-app-file-structure.png"
  /></a>
</p>
<h2 id="online-editoriai">Online editoriai</h2>
<p>Pasirinkimai:</p>
<ul>
  <li><a href="https://codesandbox.io/">https://codesandbox.io</a></li>
  <li><a href="https://stackblitz.com/">https://stackblitz.com</a></li>
</ul>
<h2 id="užduotys">Užduotys</h2>
<h3 id="užduotis-home-service-aplikacija">1. Užduotis: Home service aplikacija</h3>
<p>
  <a href="https://postimg.cc/y3Xv8zXP"><img src="https://i.postimg.cc/5yDGp4XZ/1.png" alt="1.png" /></a>
</p>
<ol>
  <li>
    <p>
      <strong>Topbar komponentas</strong>: Tai turėtų apimti logotipą ir navigacijos meniu, kuris kol kas gali būti
      statinis (vėliau bus įtrauktas react-router).
    </p>
  </li>
  <li>
    <p>
      <strong>Paieškos juosta</strong>: Centrinė paieškos juosta su mygtuku. Nors interaktyvi paieška dar nebus
      įgyvendinta, svarbu paruošti input elementą ir paieškos mygtuką.
    </p>
  </li>
  <li>
    <p>
      <strong>Kategorijos kortelė</strong>: Paslaugų sekcijoje, kiekviena paslauga (pvz., “Cleaning”, “Repair”) turėtų
      būti atvaizduojama kaip atskiras komponentas su ikona ir tekstiniu aprašymu.
    </p>
  </li>
  <li>
    <p><strong>Stilius</strong>: SCSS modules arba Styled-components</p>
  </li>
  <li>
    <p>
      <strong>Responsive design (optional)</strong>: Naudoti CSS media queries, kad puslapis tinkamai atrodytų įvairaus
      dydžio įrenginiuose.
    </p>
  </li>
  <li>
    <p>
      <strong>Būsenos valdymas</strong>: Nors šioje užduotyje būsenos valdymo galimybių nebus daug, verta paruošti
      būsimam funkcionalumui su <code>useState</code>. Galima paruošti search inputui.
    </p>
  </li>
</ol>
<blockquote>
  <p>
    Ikonoms naudoti galima
    <a href="https://react-icons.github.io/react-icons/">https://react-icons.github.io/react-icons/</a><br />
    URL based Icons: <a href="https://icons8.com/icons/">https://icons8.com/icons/</a>
  </p>
</blockquote>
<h2 id="papildomos-užduotys">Papildomos Užduotys</h2>
<h3 id="užduotis-„todo“-aplikacija">1. Užduotis: „Todo“ Aplikacija</h3>
<p>
  <strong>Tikslas</strong>: Sukurti aplikaciją, kuri leidžia vartotojams įvesti, peržiūrėti, pažymėti kaip atliktas ir
  ištrinti užduotis.
</p>
<h4 id="patarimai">Patarimai:</h4>
<ul>
  <li>Naudokite <code>useState</code> React hook užduočių sąrašo ir kiekvienos užduoties būsenai tvarkyti.</li>
  <li>
    Apsvarstykite <code>useEffect</code> hook naudojimą, kad užduotys būtų išsaugotos ir atkurtos iš naršyklės vietinės
    atminties.
  </li>
</ul>
<h4 id="iššūkiai">Iššūkiai:</h4>
<ul>
  <li>Įgyvendinkite užduočių išsaugojimą naudojant <code>localStorage</code>.</li>
  <li>Pridėkite galimybę filtruoti užduotis pagal jų būklę (visos, aktyvios, atliktos).</li>
</ul>
<h3 id="užduotis-balsavimo-aplikacija">2. Užduotis: Balsavimo Aplikacija</h3>
<p>
  <strong>Tikslas</strong>: Sukurti aplikaciją, kurioje vartotojai gali balsuoti už skirtingas parinktis ir matyti balsų
  statistiką. (vaisiai, kavos ar kt.)
</p>
<h4 id="patarimai-1">Patarimai:</h4>
<ul>
  <li>Naudokite <code>useState</code> hook kiekvienos parinkties balsams ir balsų statistikai tvarkyti.</li>
  <li>Skaičiuokite balsų procentinę dalį realiu laiku, kai tik gaunamas naujas balsas.</li>
</ul>
<h4 id="iššūkiai-1">Iššūkiai:</h4>
<ul>
  <li>Įgyvendinkite dinamišką parinkčių pridėjimą, leidžiančią vartotojams pridėti savo parinktis.</li>
  <li>
    Integruokite grafikų biblioteką, kad vizualiai pavaizduotumėte balsavimo rezultatus.
    <a href="https://blog.logrocket.com/top-8-react-chart-libraries/"
      >https://blog.logrocket.com/top-8-react-chart-libraries/</a
    >
    <ul>
      <li><a href="https://recharts.org/en-US/">https://recharts.org/en-US/</a></li>
    </ul>
  </li>
</ul>
