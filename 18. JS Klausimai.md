## JavaScript Klausimai

1. Kas yra JavaScript?

	JavaScript (dažnai trumpinama kaip JS) yra aukšto lygio, universali ir plačiai naudojama programavimo kalba, daugiausiai žinoma dėl savo vaidmens interneto svetainių kūrime. Ji leidžia įgyvendinti interaktyvų ir dinamišką elgesį interneto svetainėse.

2. Kuo skiriasi `var`, `let` ir `const` JavaScript?

	JavaScript kalboje `var` yra _function-scoped_ ir tradiciškai buvo naudojamas kintamiesiems deklaruoti. `let` ir `const` _yra block-scoped_. Pagrindinis skirtumas tarp `let` ir `const` yra tas, kad `let` leidžia kintamojo reikšmės perrašymą, o `const` leidžia ją tik nuskaityti.

3. Kuo skiriasi `null` ir `undefined`?

	`null` yra priskyriamoji reikšmė. Ji gali būti priskirta kintamajam kaip reikšmės nebuvimo atvaizdavimas. `undefined` yra primityvi reikšmė, kuri reiškia reikšmės trūkumą arba kintamąjį, kuriam nebuvo priskirta jokia reikšmė.

4. Kuo skiriasi `==` ir `===`?

	`==` lygybės operatorius konvertuoja reikšmes į tą patį tipą (jei jie nėra to paties tipo) ir tada taiko griežtą palyginimą. `===` griežtos lygybės operatorius, reikšmes laiko lygiomis tik tada, kai jos yra to paties tipo.

	```js
	console.log(1 == '1'); // true
	console.log(1 === '1'); // false
	console.log(1 === 1); // true
	```
	
5. Kokie yra skirtingi būdai deklaruoti kintamąjį JavaScript?

	Yra trys būdai deklaruoti kintamąjį JavaScript programavimo kalboje: `var`, `let` ir `const`.

6. Kas reiškia scopes JavaScript programavimo kalboje?

	Scope yra kintamųjų, objektų ir funkcijų rinkinys. JavaScript kalboje yra trys scope rušys: Global Scope, Function Scope (_Local Scope_), ir Block Scope.

7. Kas yra JavaScript ternary operatorius?

	Ternary operatorius yra sąlyginis operatorius, kuris turi tris argumentus. Jis dažnai naudojamas kaip trumpinys if sakiniui.
	
	```js
	console.log(condition ? true : false);
	```
	
8. Kaip aprašyti JavaScript _Custom Event_?

	Galite naudoti `CustomEvent` konstruktorių, norėdami sukurti pasirinktinį įvykį. `CustomEvent` konstruktorius priima du argumentus: įvykio pavadinimą ir pasirenkamą objektą, kuris nurodo įvykio parinktis. Taip pat galite naudoti `dispatchEvent` metodą, kad išsiųstumėte pasirinktinį įvykį tiksliniam elementui/dokumentui.

	#### Custom Event kūrimo pavyzdys:
	
	```js
	const event = new CustomEvent('iamjunior-updated', {
	  detail: { name: 'JavaScript' },
	});
	element.dispatchEvent(event);
	```
	
	#### Klausymas Custom Event įvykių
	
	Galite klausytis pasirinktinio įvykio naudodami `addEventListener` metodą. `addEventListener` metodas priima įvykio pavadinimą ir _callback_ funkciją, kuri yra iškviečiama, kai įvykis yra išsiunčiamas.
	
	```js
	element.addEventListener('iamjunior-updated', (event) => {
	  console.log(event.detail); // { name: 'JavaScript' }
	});
	```

	#### Įvykio klausytojų (_event listeners_) pašalinimas
	Galite pašalinti įvykio klausytojus naudodami `removeEventListener` metodą. `removeEventListener` metodas priima įvykio pavadinimą ir _callback_ funkciją, kuri buvo naudojama įvykio klausytojui (_event listener_) pridėti.
	
	```js
	function handleEvent(event) {
	  console.log(event.detail); // { name: 'JavaScript' }
	}

	element.addEventListener('iamjunior-updated', handleEvent);
	element.removeEventListener('iamjunior-updated', handleEvent);
	```
	
9. Kas yra JavaScript _closure_?
	
	_Closure_ yra funkcija, kuri turi prieigą prie savo išorinio _function scope_ net ir po to, kai išorinė funkcija yra sugrąžinta (`return`). Tai reiškia, kad _closure_ gali prisiminti ir pasiekti savo išorinės funkcijos kintamuosius ir argumentus net ir po to, kai funkcija pasibaigia. 
	
	```js
	function outer() {
	  const name = 'IamJunior';

	  function inner() {
	    console.log(name);
	  }

	  return inner;
	}

	const closure = outer();
	closure(); // IamJunior
	```
	
	Aukščiau pateiktame pavyzdyje funkcija _inner_ turi prieigą prie funkcijos _outer_ kintamojo `name` net ir po to, kai funkcija _outer_ yra baigta (`return`). Todėl funkcija _inner_ formuoja _closure_.

10. Ar _arrow_ funkcijos turi savo `this`?

	Ne, _arrow_ funkcijos neturi savo `this`. Vietoj to, jos paveldi `this` iš supančios leksinės srities.

	_Leksinė sritis (lexical scope) reiškia, kad kintamųjų ir funkcijų prieinamumas yra nustatomas pagal jų fizinę vietą kode_.

11. Ar `map()` metodas pakeičia originalų masyvą?

	Ne, `map()` metodas nekeičia originalaus masyvo. Jis grąžina naują masyvą su rezultatais, gautais pritaikant pateiktą funkciją kiekvienam pradinio masyvo elementui.
	
	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js'];

	const renamedRoadmaps = roadmaps.map((roadmap) => {
	  return `${roadmap} Roadmap`;
	});

	console.log(roadmaps); // ['JavaScript', 'React', 'Node.js']
	console.log(renamedRoadmaps); // ['JavaScript Roadmap', 'React Roadmap', 'Node.js Roadmap']
	```
	
12. Ar `forEach()` metodas grąžina naują masyvą?

	Ne, `forEach()` metodas negrąžina naujo masyvo. Jis tiesiog iškviečia pateiktą funkciją kiekvienam masyvo elementui.
	
	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js'];

	roadmaps.forEach((roadmap) => {
	  console.log(roadmap);
	});
	```
	
13. Kaip naudoti `filter()` metodą?

	 `filter()` metodas naudojamas norint filtruoti masyvą pagal tam tikrą sąlygą. `filter()` metodas sukuria naują masyvą su visais elementais, kurie atitinka pateiktos funkcijos sąlygą.
	 
	```js
	const numbers = [1, 2, 3, 4, 5, 6];

	const evenNumbers = numbers.filter((number) => {
	  return number % 2 === 0;
	});

	console.log(numbers); // [1, 2, 3, 4, 5, 6]
	console.log(evenNumbers); // [2, 4, 6]
	```
	
14. Kuo skiriasi `map()` ir `forEach()` metodai?

	`map()` metodas sukuria naują masyvą su rezultatais, gautais pritaikant pateiktą funkciją kiekvienam masyvo elementui. Tuo tarpu `forEach()` metodas vykdo pateiktą funkciją kiekvienam masyvo elementui, tačiau negrąžina naujo masyvo. Šie metodai nedaro pakitimų pradiniam masyvui.

15. Kaip naudoti `reduce()` metodą?

	`reduce()` metodas naudojamas norint sumažinti masyvą iki vienos reikšmės. `reduce()` metodas vykdo reduktoriaus funkciją (kurią jūs pateikiate) kiekvienam masyvo elementui. Šis metodas gražina vieną išvesties reikšmę.
	
	#### Sintaksė:
	
	```js
	array.reduce((accumulator, currentValue) => {
	  // ...
	}, initialValue);
	```
	
	#### Pavyzdys:
	Galite naudoti `reduce()` metodą, norėdami susumuoti visus masyvo skaičius.
	
	```js
	const numbers = [1, 2, 3, 4, 5, 6];

	const sum = numbers.reduce((accumulator, currentValue) => {
	  return accumulator + currentValue;
	}, 0);

	console.log(numbers); // [1, 2, 3, 4, 5, 6]
	console.log(sum); // 21
	```
	
16. Kuo skiriasi `map()` ir `reduce()` metodai?

	`map()` metodas sukuria naują masyvą su rezultatais, gautais pritaikant pateiktą funkciją kiekvienam pradinio masyvo elementui. Tuo tarpu `reduce()` metodas vykdo reduktoriaus funkciją (kurią jūs pateikiate) kiekvienam masyvo elementui, gaudamas vieną išvesties reikšmę.
	
17. Kas yra prototipo grandinė (_Prototype Chain_) JavaScript?

	JavaScript Prototipo grandinė reiškia objektų grandinę, susietą jų prototipais. Kai prieinama prie objekto savybės ar metodo, JavaScript pirmiausia patikrina patį objektą. Jei savybė ar metodas ten nerandamas, ieškoma objekto prototipe. Šis procesas tęsiasi, judant grandine aukštyn nuo vieno prototipo prie kito, kol savybė ar metodas randamas arba kol pasiekiama grandinės pabaiga (paprastai bazinio objekto prototipas, kuris yra null). Prototipo grandinė yra esminė JavaScript prototipinio paveldėjimo modelio dalis, leidžianti objektams paveldėti savybes ir metodus iš kitų objektų.

	#### Pavyzdys:
	
	```js
	const course = {
	  getCourseUrl() {
	    console.log(`https://iamjunior.lt/kursai/${this.slug}`);
	  },
	};

	const javascript = {
	  name: 'Web programavimas su Javascript',
	  description: 'Mokykis JavaScript',
	  slug: 'web-programavimas-javascript',
	  greet() {
	    console.log(`${this.name} - ${this.description}`);
	  },
	};

	Object.setPrototypeOf(javascript, course); // or javascript.__proto__ = course;

	javascript.getCourseUrl(); // https://iamjunior.lt/kursai/web-programavimas-javascript
	javascript.greet(); // Web programavimas su Javascript - Mokykis JavaScript
	```
	
	Šiame pavyzdyje `javascript` objektas paveldi `getCourseUrl()` metodą iš `course` objekto. Taip yra todėl, kad `javascript` objekto prototipas yra nustatytas į `course` objektą naudojant `Object.setPrototypeOf()` metodą. `javascript` objekte `getCourseUrl()` metodas nėra rastas, todėl JavaScript kalba ieško šio metodo, prototipo grandinėje ir randa `getCourseUrl()` metodą `course` objekte.

18. Kas yra IIFE JavaScript?

	IIFE (_Immediately Invoked Function Expression_) yra JavaScript funkcija, kuri vykdoma iškart, kai ji yra apibrėžiama.
	
	```js
	(function () {
	  console.log('Hello IamJunior!');
	})();
	```
	
	IIFE dažnai naudojama kuriant naują _scope_, siekiant išvengti kintamųjų kėlimo (_hoisting_) iš blokų.
	
	```js
	(function () {
	  var course = 'JavaScript';
	  console.log(course);
	})();

	console.log(course); // ReferenceError: name is not defined
	```
	
19. Kas yra JavaScript paveldimumas?

	Paveldimumas yra būdas sukurti naują klasę iš esamos klasės. Naujoji klasė paveldi visas savybes ir metodus iš esamos klasės. Naujoji klasė vadinama vaikine klase, o esama klasė vadinama tėvine klase.
	#### Pavyzdys:
	
	```js
	class Course{
	  constructor(name, description, slug) {
	    this.name = name;
	    this.description = description;
	    this.slug = slug;
	  }

	  getCourseUrl() {
	    console.log(`https://iamjunior.lt/kursai/${this.slug}`);
	  }
	}

	class JavaScript extends Course {
	  constructor(name, description, slug) {
	    super(name, description, slug);
	  }

	  greet() {
	    console.log(`${this.name} - ${this.description}`);
	  }
	}

	const js = new JavaScript(
	  'Web programavimas su Javascript',
	  'Mokykis JavaScript',
	  'web-programavimas-javascript'
	);

	js.getRoadmapUrl(); // https://iamjunior.lt/kursai/web-programavimas-javascript
	js.greet(); // Web programavimas su Javascript - Mokykis JavaScript
	```
	
	Aukščiau pateiktame pavyzdyje JavaScript klasė paveldi `getCourseUrl()` metodą iš `Course` klasės. Taip yra todėl, kad JavaScript klasė praplečia `Course` klasę naudodama `extends` raktinį žodį. JavaScript klasėje `getCourseUrl()` metodas nerandamas, todėl JavaScript ieško prototipo grandinėje ir randa `getCourseUrl()` metodą `Course` klasėje.
	
20. Kas yra JavaScript `Map`?

	`Map` yra JavaScript duomenų struktūra, kuri yra panaši į objektą, tačiau raktas (_key_) gali būti bet kokio tipo. Tai elementų rinkinys, kur kiekvienas elementas yra saugomas kaip raktas-vertės (_key-value_) pora. Jis taip pat žinomas kaip _Hash table_ arba žodynas.

	Raktas (_key_) yra unikalus ir nekintamas (_immutable_), o vertė gali būti kintama (_mutable_) arba nekintama (_immutable_).
	
	```js
	const course = new Map();
	course.set('name', 'JavaScript');
	course.set('type', 'dynamic');
	course.set('year', 2024);

	console.log(course.get('name')); // JavaScript

	course.delete('year');
	console.log(course.has('year')); // false
	console.log(course.size); // 2

	course.clear();
	console.log(course.size); // 0
	```
	
21. Kas yra JavaScript Set?

	Set yra kita JavaScript duomenų struktūra, kuri yra panaši į masyvą, tačiau jos reikšmės yra unikalios. Tai elementų rinkinys, kur kiekvienas elementas yra saugomas kaip reikšmė be jokių raktų.

	```js
	const course = new Set();
	course.add('JavaScript');
	course.add('JavaScript');

	course.add('dynamic');
	course.add(1995);

	console.log(course.size); // 3, because the value 'JavaScript' is already present in the set
	console.log(course.has('JavaScript')); // true

	course.delete('JavaScript');
	console.log(course.has('JavaScript')); // false
	console.log(course.size); // 2
	```
	
22. Kaip rasti unikalias reikšmes masyve?

	Yra keli būdai rasti unikalias reikšmes masyve. Štai keletas iš jų:
	
	- Naudojant `Set`

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js', 'Node.js', 'JavaScript'];
	const uniqueRoadmaps = [...new Set(roadmaps)];
	console.log(uniqueRoadmaps); // ['JavaScript', 'React', 'Node.js']
	```

	- Naudojant `filter()`

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js', 'Node.js', 'JavaScript'];
	const uniqueRoadmaps = roadmaps.filter(
	  (roadmap, index) => roadmaps.indexOf(roadmap) === index
	);
	console.log(uniqueRoadmaps); // ['JavaScript', 'React', 'Node.js']
	```
	
	- Naudojant `reduce()`

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js', 'Node.js', 'JavaScript'];
	const uniqueRoadmaps = roadmaps.reduce((unique, roadmap) => {
	  return unique.includes(roadmap) ? unique : [...unique, roadmap];
	}, []);
	console.log(uniqueRoadmaps); // ['JavaScript', 'React', 'Node.js']
	```
	
	- Naudojant `forEach()`

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js', 'Node.js', 'JavaScript'];
	const uniqueRoadmaps = [];
	roadmaps.forEach((roadmap) => {
	  if (!uniqueRoadmaps.includes(roadmap)) {
	    uniqueRoadmaps.push(roadmap);
	  }
	});
	console.log(uniqueRoadmaps); // ['JavaScript', 'React', 'Node.js']
	```
	
	- Naudojant `for...of`

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js', 'Node.js', 'JavaScript'];
	const uniqueRoadmaps = [];
	for (const roadmap of roadmaps) {
	  if (!uniqueRoadmaps.includes(roadmap)) {
	    uniqueRoadmaps.push(roadmap);
	  }
	}
	console.log(uniqueRoadmaps); // ['JavaScript', 'React', 'Node.js']
	```
	
23. Kas yra JavaScript pažadas (_Promise_)?

	JavaScript pažadas (_Promise_) - reikšmė, kuri dar neprieinama, bet bus pasiekiama tam tikru momentu. Pažadai suteikia būdą valdyti asinchronines operacijas, siūlydami metodus, tokius kaip `.then()` ir `.catch()`, kurie leidžia užregistruoti _callback_ funkcijas sėkmei ir nesėkmei valdyti.

24. Kokia yra `async/await` paskirtis?

	`async/await`, pristatytas ES2017, suteikia labiau skaitomą ir švaresnį būdą valdyti asinchronines operacijas, palyginti su atgaliniais kvietimais (_callbacks_) ir pažadais (_promises_). `async` funkcija visada grąžina pažadą (_promise_), o tokios funkcijos viduje galite naudoti `await`, kad sustabdytumėte vykdymą, kol pažadas bus įvykdytas.

25. Kas yra JavaScript „callback hell“?

	„Callback hell“, dažnai vadinamas „Pragaro piramidė“ (_Pyramid of Doom_), apibūdina JavaScript situaciją, kai daugybė įdėtųjų atgalinių kvietimų (_callbacks_) tampa sunkiai valdomi, todėl kodas tampa sunkiai skaitomas ir prižiūrimas. Su šia problema dažnai susiduriama, kai atliekamos kelios asinchroninės operacijos, priklausančios nuo ankstesnių operacijų užbaigimo. Kodas pradeda įgyti piramidinę formą dėl įdėjimo (_nesting_).
	#### „Pragaro piramidės“ (_Pyramid of Doom_) pavyzdys
	
	```js
	callAsync1(function () {
	  callAsync2(function () {
	    callAsync3(function () {
	      callAsync4(function () {
	        callAsync5(function () {
	          // ...
	        });
	      });
	    });
	  });
	});
	```
	
	#### Strategijos, kaip išvengti „callback hell“

	Programuotojai gali išvengti „callback hell“ naudodamiesi tokiomis strategijomis kaip:

	- Kodo modularizavimas į pavadintas funkcijas.
	- Naudojant asinchroninio valdymo srautų bibliotekas.
	- Pasinaudojant moderniomis JavaScript funkcijomis, tokiomis kaip Promises ir `async`/`await`, kad būtų rašomas labiau linijinis, skaitomas asinchroninis kodas.

	#### Pažadų grandinė (_Promise chaining_)

	```js
	callAsync1()
	  .then(() => callAsync2())
	  .then(() => callAsync3())
	  .then(() => callAsync4())
	  .then(() => callAsync5())
	  .catch((err) => console.error(err));
	```
	
	### Async/await
	
	```js
	async function asyncCall() {
	  try {
	    await callAsync1();
	    await callAsync2();
	    await callAsync3();
	    await callAsync4();
	    await callAsync5();
	  } catch (err) {
	    console.error(err);
	  }
	}
	```
	
26. Kaip įjungti griežtąjį JavaScript režimą (_strict mode_)?

	Norėdami įjungti griežtąjį JavaScript režimą, turite pridėti šią eilutę failo arba funkcijos viršuje: `'use strict';`.

27. Paaiškinkite `alert()`, `prompt()` ir `confirm()` JavaScript metodus?

	Pažiūrėkime, kaip galime naudoti `alert`, `prompt` ir `confirm` funkcijas, kad sąveikautume su vartotoju.

	- **`alert()`**

		`alert()` metodas rodo įspėjimo langą su nurodyta žinute ir OK mygtuku.
		
	```js
		alert('Hello World!');
	```
	
	- **`prompt()`**

		`prompt()` metodas rodo dialogo langą, kuriame prašoma vartotojo įvesties. Prompt langas dažnai naudojamas, kai norima, kad vartotojas įvestų reikšmę prieš įeinant į puslapį. `prompt()` metodas grąžina įvestą reikšmę, jei vartotojas spusteli OK. Jei vartotojas spusteli Cancel, metodas grąžina `null`.
		
	```js
		const name = prompt('What is your name?');
		console.log(name);
	```
	
	- **`confirm()`**

		`confirm()` metodas rodo dialogo langą su nurodyta žinute, kartu su OK ir Cancel mygtukais. Šis metodas dažnai naudojamas, vartotojo patvirtinimui.
		
	```js
		const result = confirm('Are you sure?');
		console.log(result); // true/false
	```
	
28. Kaip valdyti JavaScript _event bubbling_?

	_event bubbling_ yra sąvoka Dokumento Objektų Modelyje (DOM), apibūdinanti, kaip įvykiai plinta arba "burbuliuoja" per įdėtų elementų hierarchiją DOM struktūroje.

	Kai DOM elemente įvyksta įvykis, pvz., pelės paspaudimas, šis įvykis pirmiausia bus apdorotas pačiame elemente, tada jo tėviniame elemente ir t. t., kol įvykis pasieks šakninį elementą. Šis elgesys vadinamas _event bubbling_.
	
	```js
	const parent = document.querySelector('.parent');
	const child = document.querySelector('.child');

	// Scenario of clicking on the child element
	parent.addEventListener('click', () => {
	  console.log('Handled Last');
	});

	child.addEventListener('click', () => {
	  console.log('Handled First');
	});
	```
	
	Aukščiau pateiktame pavyzdyje, kai spustelėsite vaiko elementą, įvykis pirmiausia bus apdorotas vaiko elemente, tada jo tėviniame elemente ir t. t., iki _root_ elemento, nebent sustabdysite įvykio plitimą naudodami `event.stopPropagation()`.
	
	```js
	child.addEventListener('click', (event) => { event.stopPropagation(); 	
	console.log('Apdorotas tik vaiko elemente'); });
	```
	
29.  Kas yra JavaScript įvykių fiksavimas (_Event Capturing_)?

		Įvykių fiksavimas yra pirmoji įvykių plitimo fazė. Šioje fazėje įvykis yra fiksuojamas išoriniame elemente ir perduodamas vidiniams elementams. Tai taip pat žinoma kaip nutekėjimas (_trickling_). Tai yra _event bubbling_ priešingybė.

30. Kas yra JavaScript _spread_ operatorius?
	
	JavaScript _spread_ operatorius yra vaizduojamas trimis taškais (`...`). Jis leidžia masyvo elementus arba objekto savybes išskleisti arba "išsklaidyti" į atskirus elementus arba savybes. Tai gali būti naudinga įvairiuose kontekstuose, pvz., perduodant elementus kaip funkcijos argumentus, klonuojant masyvus ir objektus arba sujungiant masyvus ir objektus.

	```js
	const roadmaps = ['JavaScript', 'React', 'Node.js'];
	const bestPractices = ['AWS', 'API Security'];

	const resources = [...roadmaps, ...bestPractices];
	console.log(resources); // ['JavaScript', 'React', 'Node.js', 'AWS', 'API Security']
	```
	```js
	const roadmap = {
	  name: 'JavaScript',
	  type: 'dynamic',
	};

	const roadmapClone = { ...roadmap }; // shallow copy
	console.log(roadmapClone); // { name: 'JavaScript', type: 'dynamic' }
	```
	
31. Ar Java ir JavaScript yra tas pats?

	Ne, Java ir JavaScript yra skirtingos programavimo kalbos. Jų panašumas pavadinime yra atsitiktinis, kaip žodžių "car" (automobilis) ir "carpet" (kilimas). Java dažnai naudojama backend ir mobiliosioms programėlėms, o JavaScript suteikti interaktyvumo žiniatinklio puslapiams, frontend ir backend kūrimui.

32. Kas yra JavaScript `preventDefault()` metodas?

	`event.preventDefault()` metodas naudojamas norint sustabdyti įvykio numatytą veiksmą. Pavyzdžiui, kai spustelėjate nuorodą, numatytasis veiksmas yra pereiti į nuorodos URL puslapį. Tačiau, jei norite sustabdyti naršymą, galite naudoti `event.preventDefault()` metodą.

	```js
	const link = document.querySelector('a');

	link.addEventListener('click', (event) => {
	  event.preventDefault();
	  console.log('Clicked on link!');
	});
	```

33. Kas yra JavaScript _Hoisting_?

	_Hoisting_ yra JavaScript mechanizmas, kuriame kintamųjų ir funkcijų deklaracijos yra perkeliamos į savo _scope_ viršų prieš kodo vykdymą. Tai reiškia, kad nesvarbu, kur funkcijos ir kintamieji yra deklaruoti, jie yra perkelti į savo _scope_ viršų, nesvarbu, ar jų _scope_ yra globalus (_global_), ar vietinė (_local_). Reikėtų atkreipti dėmesį, kad _hoisting_ perkelia tik deklaraciją, o ne priskyrimą (_initialization_).

	```js
	console.log(x === undefined); // true
	var x = 3;
	console.log(x); // 3
	```
	
	Aukščiau pateiktą kodo fragmentą galima vizualizuoti taip:

	```js
	var x;
	console.log(x === undefined); // true
	x = 3;
	console.log(x); // 3
	```

34. Kas yra DOM?

	Dokumentų Objektų Modelis (DOM) yra programavimo sąsaja HTML ir XML dokumentams. Jis atvaizduoja puslapį taip, kad programos galėtų keisti dokumento struktūrą, stilių ir turinį. DOM atvaizduoja dokumentą kaip mazgus (_nodes_) ir objektus.

35. Kuo skiriasi `Promise.all()` ir `Promise.allSettled()`?

	Pagrindinis skirtumas tarp `Promise.all()` ir `Promise.allSettled()` yra tas, kad `Promise.all()` atmeta iškart, jei bet kuris vienas iš pažadų atmetamas, o `Promise.allSettled()` laukia, kol visi pažadai bus užbaigti (arba įvykdyti, arba atmesti), ir tada grąžina rezultatą.
	
	#### Inicializavimas:

	```js
	const promise1 = Promise.resolve('Promise 1 resolved');
	const promise2 = Promise.reject('Promise 2 rejected');
	```

	#### `Promise.all()` naudojimas:

	```js
	Promise.all([promise1, promise2])
	  .then((values) => {
	    console.log(values);
	  })
	  .catch((error) => {
	    console.log('An error occurred in Promise.all():', error);
	  });

	// Output:
	// An error occurred in Promise.all(): Promise 2 rejected
	```

	Aukščiau pateiktame kode `Promise.all()` atmetamas iškart, kai `promise2` yra atmetamas.

	#### `Promise.allSettled()` naudojimas:

	```js
	Promise.allSettled([promise1, promise2]).then((results) => {
	  results.forEach((result, index) => {
	    if (result.status === 'fulfilled') {
	      console.log(
	        `Promise ${index + 1} was fulfilled with value:`,
	        result.value
	      );
	    } else {
	      console.log(
	        `Promise ${index + 1} was rejected with reason:`,
	        result.reason
	      );
	    }
	  });
	});

	// Output:
	// Promise 1 was fulfilled with value: Promise 1 resolved
	// Promise 2 was rejected with reason: Promise 2 rejected
	```

	Aukščiau pateiktame kode `Promise.allSettled()` laukia, kol visi pažadai bus užbaigti (arba įvykdyti, arba atmesti), ir tada grąžina rezultatą.

36. Kuo skiriasi JavaScript `Map` ir `WeakMap`?

	`Map` objektas laiko _key-value_ poras ir prisimena originalią raktų (_key_) įterpimo tvarką. Tuo tarpu `WeakMap` objektas yra raktų/verčių porų rinkinys, kuriame raktai yra silpnai nurodyti. `Map` galite naudoti bet kokio tipo duomenis kaip raktus ar vertes, tuo tarpu `WeakMap` galite naudoti tik objektus kaip raktus. `WeakMap` nėra iteruojamas, o `Map` yra. `WeakMap` laiko silpną nuorodą į originalų objektą, tai reiškia, kad jei nėra kitų nuorodų į objektą, saugomą `WeakMap`, tie objektai gali būti pašalinti iš atminties (_garbage collected_).

37. Kas yra JavaScript Atminties valymas (_Garbage collection_)?

	JavaScript variklis naudoja automatinį atminties valymą. JavaScript automatiškai tvarko atmintį atlaisvindamas vietą, kurią naudoja objektai, kurie nebėra reikalingi. Šis algoritmas vadinamas "Mark and Sweep" ir periodiškai vykdomas JavaScript variklio.

38. Kaip padaryti JavaScript objektą nekintamą (_immutable_)?

	Norėdami padaryti objektą nekintamą, galite naudoti `Object.freeze()` metodą. Jis neleidžia keisti esamų savybių reikšmių (_property values_) ir neleidžia pridėti naujų savybių (_properties_).

	```js
	const course = {
	  name: 'JavaScript',
	};

	Object.freeze(course);

	course.name = 'JavaScript Course'; // throws an error in strict mode
	console.log(course.name); // JavaScript
	```

39. Kas yra tipų keitimas (_Type Casting_)?

	Tipų konvertavimas (arba tipų keitimas (_typecasting_)) reiškia duomenų perkėlimą iš vieno duomenų tipo į kitą. _Implicit_ (numanomas) konvertavimas įvyksta, kai kompiliatorius (kompiliuojamose kalbose) arba vykdymo laikas (_runtime_) (skriptų kalbose, tokiose kaip JavaScript) automatiškai konvertuoja duomenų tipus.

40. Kas yra JavaScript _Explicit binding_?

	Aiškus susiejimas (_explicit binding_) yra būdas aiškiai nurodyti, kam bus susietas `this` raktinis žodis, naudojant funkcijų `call`, `apply` arba `bind` metodus.

	```js
	const course = {
	  name: 'JavaScript',
	};

	function printName() {
	  console.log(this.name);
	}

	printName.call(course); // JavaScript
	printName.apply(course); // JavaScript

	const printCourseName = printName.bind(course);
	printCourseName(); // JavaScript
	```

	Aukščiau pateiktame pavyzdyje `this` raktinis žodis funkcijos `printName()` viduje yra aiškiai susietas su `course` objektu naudojant `call`, `apply` arba `bind` metodus.

41. Kaip vykdyti kodo dalį po tam tikro laiko intervalo?

	Galite vykdyti kodą intervalais naudodami `setInterval` funkciją. Ji priima funkciją ir laiko intervalą milisekundėmis. Ji grąžina unikalų ID, kurį galite naudoti norėdami nutraukti intervalą naudodami `clearInterval` funkciją.

	```js
	const intervalId = setInterval(() => {
	  console.log('Hello World');
	}, 1000);

	// Output:
	// Hello World
	// Hello World
	```

	Aukščiau pateiktame kode `setInterval` funkcija vykdo _callback_ funkciją kas 1000 milisekundžių (1 sekundė) ir spausdina "Hello World" į konsolę. Ji grąžina unikalų ID, kurį galite naudoti norėdami nutraukti intervalą naudodami `clearInterval` funkciją.

	```js
	clearInterval(intervalId);
	```

42. Kas yra JavaScript pažymėti sakiniai (_Labelled Statements_)?

	JavaScript pažymėti sakiniai naudojami, prie identifikatoriaus pridėti etiketę (_prefix_). Jie gali būti naudojami su `break` ir `continue` sakiniais, kad būtų tiksliau valdomas vykdymo srautas (_flow_).

	```js
	loop1: for (let i = 0; i < 5; i++) {
	  if (i === 1) {
	    continue loop1; // skips the rest of the code in the loop1
	  }
	  console.log(`i: ${i}`);
	}
	// Output:
	// i: 0
	// i: 2
	// i: 3
	// i: 4
	```

43. Kuo skiriasi JavaScript `defer` ir `async` atributai?

	Pagrindinis skirtumas tarp `defer` ir `async` yra vykdymo tvarka.

	#### Defer atributas

	Jei `<script>` elementas turi `defer` atributą, HTML puslapis bus toliau kraunamas ir rodomas, kol skriptas bus atsisiunčiamas. Skriptas vykdomas po to, kai HTML puslapis yra visiškai suanalizuotas. `defer` skriptai išlaiko savo tvarką dokumente.
	
	```html
	<script defer src="script1.js"></script>
	<script defer src="script2.js"></script>
	```

	Aukščiau pateiktame pavyzdyje `script1.js` bus vykdomas prieš `script2.js`. Naršyklė atsisiųs abu skriptus lygiagrečiai, tačiau `script1.js` bus vykdomas po to, kai HTML puslapis bus suanalizuotas, ir `script2.js` bus vykdomas po `script1.js`.

	#### Async atributas

	Kita vertus, jei `<script>` elementas turi `async` atributą, HTML analizatorius bus pristabdytas ir skriptas bus vykdomas iškart po jo atsisiuntimo. HTML analizė bus tęsiama po skripto vykdymo.

	```html
	<script async src="script1.js"></script>
	<script async src="script2.js"></script>
	```

	Aukščiau pateiktame pavyzdyje naršyklė atsisiųs abu skriptus lygiagrečiai ir vykdys juos iškart po atsisiuntimo. Vykdymo tvarka nėra garantuota.

	 `defer` ir `async` gilesnis skirtumo paaiškinimas:
	![enter image description here](https://roadmap.sh/guides/avoid-render-blocking-javascript-with-async-defer.png)
44. Kas yra JavaScript sudėties operatorius?

	Kaip rodo pavadinimas, sudėties operatorius padidina kintamojo reikšmę 1. Yra du sudėties operatorių tipai: `pre-increment` ir `post-increment`.

	#### Pre-increment operatorius

	Pre-increment operatorius padidina kintamojo reikšmę 1 ir tada grąžina rezultatą. Pavyzdžiui:

	```js
	let x = 1;
	console.log(++x); // 2
	console.log(x); // 2
	```

	#### Post-increment operatorius

	Post-increment operatorius grąžina kintamojo reikšmę ir tada padidina ją 1. Pavyzdžiui:

	```js
	let x = 1;
	console.log(x++); // 1
	console.log(x); // 2
	```

45. Kaip priimti kintantį argumentų skaičių, JavaScript funkcijoje?

	Norint priimti kintamą skaičių argumentų, JavaScript funkcijoje, naudodami arguments objektą arba rest parametrą `(...)`.

	#### Naudojant `arguments` objektą:

	`arguments` yra į masyvą panašus objektas, kuris laiko visus perduotus argumentus. Jie yra prieinami tik funkcijos kūne.

	```js
	function displayArgs() {
	  for (let i = 0; i < arguments.length; i++) {
	    console.log(arguments[i]);
	  }
	}
	displayArgs(1, 2, 3, 4); // Outputs: 1, 2, 3, 4
	```

	#### Naudojant _rest_ parametrą:

	_Rest_ parametras leidžia atvaizduoti neribotą skaičių argumentų kaip masyvą.

	```js
	function displayArgs(...args) {
	  args.forEach((arg) => console.log(arg));
	}
	displayArgs(1, 2, 3, 4); // Outputs: 1, 2, 3, 4
	```

	_Rest_ parametras (`...args` pavyzdyje) paprastai yra modernesnis ir lankstesnis, be to, jis suteikia tikrą masyvą, skirtingai nei į masyvą panašus `arguments` objektas.

46. Kaip apibrėžti JavaScript _multiline strings_?

	Norint apibrėžti JavaScript _multiline strings_, reikia naudoti šablonines eilutes (_template literals_). Šabloninės eilutės yra įrėmintos naudojant (``) (_backtics_) kabutes vietoj dvigubų arba viengubų kabučių. Šabloninės eilutės gali turėti pakaitinius žymeklius (_placeholders_). Jie yra nurodomi dolerio ženklu ir garbanotais skliaustais (`${expression}`).

47. Kaip naudojami JavaScript `break` ir `continue` sakiniai (_statements_)?

	`break` ir `continue` naudojami cikluose (_loops_), kad pakeistumėte ciklo eigą. `break` sustabdys ciklą, neleidžiant jam tęstis, o `continue` praleis esamą iteraciją ir pratęs.

	```js
	for (let i = 0; i < 5; i++) {
	  if (i === 1) {
	    continue; // skips the rest of the code in the loop
	  }
	  console.log(`i: ${i}`);
	}

	// Output:
	// i: 0
	// i: 2
	// i: 3
	// i: 4
	```

	```js
	for (let i = 0; i < 5; i++) {
	  if (i === 1) {
	    break; // stops the loop
	  }
	  console.log(`i: ${i}`);
	}

	// Output:
	// i: 0
	```

48. Kaip išanalizuoti (_parse_) JSON structurą?

	Norėdami išanalizuoti (_parse_) JSON, galite naudoti metodą `JSON.parse()`. Jis išanalizuoja JSON eilutę (_JSON string_) ir grąžina jos JavaScript atitikmenį.

	```js
	const json = '{"name":"JavaScript","year":1995}';
	const course = JSON.parse(json);

	console.log(course.name); // JavaScript
	console.log(course.year); // 1995
	```

49. Kaip sutvarkyti (_debug_) JavaScript kodą?

	JavaScript kodo tvarkymas (_debugging_) gali būti pasiektas naudojant įvairius metodus ir įrankius. Štai pagrindinės instrukcijos:

	#### Konsolės žurnalas (_Console Logging_):

	Galite naudoti `console.log()`, `console.warn()`, `console.error()` ir pan., kad atspausdintumėte reikšmes, kintamuosius ar žinutes į naršyklės kūrėjo konsolę (_dev tools console_).

	```js
	console.log('Value of x:', x);
	```

	#### Naršyklės kūrėjo įrankiai (_Browser Developer Tools_):

	Dauguma šiuolaikinių naršyklių turi įdiegtus kūrėjo įrankius. Galite pasiekti šiuos įrankius paspausdami F12 arba dešiniuoju pelės mygtuku spustelėję tinklalapį ir pasirinkę „Inspect“ arba „Inspect Element“.

	-   **Sources Tab**: Leidžia matyti įkeltus scenarijus, nustatyti stabdymo taškus ir pereiti per kodą žingsnis po žingsnio.
	-   **Console Tab**: Rodo konsolės išvestis ir leidžia interaktyviai vykdyti JavaScript kodą.
	-   **Network Tab**: Padeda tikrinti tinklo užklausas ir atsakymus.

	#### Stabdymo taškų nustatymas (_Setting Breakpoints_):

	Naršyklės kūrėjo įrankių „Sources“ skirtuke galite spustelėti eilutės numerį, kad nustatytumėte stabdymo tašką. Kodo vykdymas sustos ties šia eilute, leisdamas jums tikrinti kintamuosius, kvietimų rinkinį (_call stack_) ir tęsti vykdymą žingsnis po žingsnio.

	#### Tavrkymo pareiškimas (_Debugger Statement_):

	Įterpdami `debugger;` pareiškimą į savo kodą, jis veiks kaip stabdymo taškas, kai naršyklės kūrėjo įrankiai yra atidaryti. Vykdymas sustos ties `debugger;` eilute.

	```js
	function myFunction() {
	  debugger; // Execution will pause here when dev tools are open
	  // ... rest of the code
	}
	```

	#### Kvietimų rinkinys ir veiklos sritis (_Call Stack and Scope_):

	Kūrėjo įrankiuose (_dev tools_), kai sustojama ties stabdymo tašku arba `debugger;` pareiškimu, galite tikrinti kvietimų rinkinį (_call stack_), kad pamatytumėte funkcijų kvietimų seką. Veiklos srities (_scope_) skydelis parodys vietinių (_local_) ir globalių (_global_) kintamųjų reikšmes.

	Atminkite, kad kodo tvarkymas (_debugging_) yra iteracinis procesas. Jis dažnai apima stabdymo taškų nustatymą, kintamųjų tikrinimą, kodo koregavimą ir pakartotinį vykdymą, siekiant užtikrinti taisyklingą veikimą.

50. Kaip tvarkyti _Promise_ klaidas?

	Norint tvarkyti klaidas pažaduose (_Promise_), galime naudoti `catch` metodą arba antrąjį `then` metodo argumentą.
	
	#### Pažado atmetimas (_Promise reject_)

	```js
	const promise = new Promise((resolve, reject) => {
	  reject(new Error('Something went wrong'));
	});
	```

	#### `catch` metodas

	Šiuo metodu galime perduoti _callback_ funkciją, kuri bus iškviečiama, kai pažadas (_Promise_) bus atmestas (`rejected`).

	```js
	promise
	  .then((result) => {
	    console.log(result);
	  })
	  .catch((error) => {
	    console.log(error.message);
	  });
	```

	#### Antrasis `then` metodo argumentas
	
	Šiuo metodu galime perduoti dvi `callback` funkcijas kaip argumentus. Pirmoji bus iškviečiama, kai pažadas (_Promise_) bus įvykdytas (`resolved`), o antroji bus iškviečiama, kai pažadas (_Promise_) bus atmestas (`rejected`).

	```js
	promise.then(
	  (result) => {
	    console.log(result);
	  },
	  (error) => {
	    console.log(error.message);
	  }
	);
	```

51. Kaip tvarkyti klaidas naudojant `async`/`await`?

	Norint tvarkyti klaidas naudojant `async`/`await`, galime naudoti `try`/`catch` sakinį.

	#### Pažado atmetimas (_Promise reject_)

	```js
	const promise = new Promise((resolve, reject) => {
	  reject(new Error('Something went wrong'));
	});
	```

	#### `try`/`catch` sakinys

	```js
	async function main() {
	  try {
	    const result = await promise;
	    console.log(result);
	  } catch (error) {
	    console.log(error.message);
	  }
	}
	```

	`catch` blokas bus vykdomas, kai pažadas (_Promise_) bus atmestas arba kai `try` bloke bus išmesta klaida.

52. Kaip naudoti `finally` bloką pažado (_Promise_) viduje?

	`finally` blokas bus vykdomas, kai pažadas bus įvykdytas arba atmestas.

	```js
	promise
	  .then((result) => {
	    console.log(result);
	  })
	  .catch((error) => {
	    console.log(error.message);
	  })
	  .finally(() => {
	    console.log('Finally Promise has settled');
	  });
	```

53. Asinchroninis kodas vs Sinchroninis kodas?

	Skirtumas tarp asinchroninio ir sinchroninio kodo yra tas, kad asinchroninis kodas neblokuoja programos vykdymo. Tuo tarpu, sinchroninis kodas - blokuoja.

	#### Asinchroninis kodas (_Asynchronous_)

	Asinchroninis kodas vykdomas fone ir neblokuoja programos vykdymo. Jis dažniausiai naudojamas užduotims, kurios užtrunka ilgą laiką, pavyzdžiui, tinklo užklausoms atlikti (_network requests_).

	```js
	console.log('Before');

	setTimeout(() => {
	  console.log('Hello');
	}, 1000);

	console.log('After');
	```

	#### Sinchroninis kodas (_Synchronous_)

	Sinchroninis kodas vykdomas paeiliui ir blokuoja tolesnį programos vykdymą, kol jis yra užbaigtas. Jei užduotis užtrunka ilgą laiką, likęs programos kodas laukia sinchroninio kodo vykdymo pabaigos.
	
	```js
	console.log('Before');

	for (let i = 0; i < 1000000000; i++) {}

	console.log('After');
	```

54. Kas yra JavaScript įvykių ciklas (_Event Loop_)?

	Įvykių ciklas (_event loop_) yra vienas iš svarbiausių JavaScript aspektų. Tai mechanizmas, leidžiantis JavaScript atlikti neblokuojančias operacijas. Dėl šio mechanizmo galime naudoti asinchroninį kodą. Įvykių ciklas (_event loop_) yra ciklas, kuris nuolat tikrina, ar yra užduočių, kurias reikia vykdyti. Jei tokių yra, ji jas vykdys. Jei nėra užduočių, ji laukia naujų užduočių atsiradimo.

55. Kaip veikia JavaScript įvykių ciklas (_Event Loop_)?

	Įvykių ciklas turi dvi pagrindines dalis: Kvieimų rinkinį (_Call stack_) ir _callback_ eilę (_Callback queue_).

	#### Kvieimų rinkinys (_Call Stack_)

	Kvieimų rinkinys (_Call Stack_), yra duomenų struktūra, kuri saugo užduotis, kurias reikia vykdyti. Tai yra LIFO (_Last In, First Out_) duomenų struktūra, o tai reiškia, kad paskutinė užduotis, pridėta į kvietimų rinkinį, bus vykdoma pirma.

	#### Callback eilė (_Callback Queue_)

	Callback eilė (_Callback Queue_), yra duomenų struktūra, kuri saugo užbaigtas ir paruoštas vykdyti užduotis. Tai yra FIFO (_First In, First Out_) duomenų struktūra, o tai reiškia, kad pirma pridėta užduotis į _callback_ eilę bus vykdoma pirma.

	#### Įvykių kilpos darbo eiga (_Event Loop's Workflow_):

	1.  Vykdo užduotis iš kvietimų rinkinio (_call stack_).
	2.  Asinchroninei užduočiai, tokiai, kaip laikmatis (_timer_), ji veikia fone. JavaScript tęsia kitą užduotį nelaukiant.
	3.  Kai asinchroninė užduotis baigiasi, jos `callback` funkcija pridedama į _callback_ eilę (_callback queue_).
	4.  Jei kivetimų rinkinys (_call stack_) yra tuščias ir yra užduočių _callback_ eilėje (_callback queue_), įvykių ciklas perkelia pirmą užduotį iš _callback_ eilės (_callback queue_) į kvieimų rinkinį (_call stack_) vykdymui.

	```js
		setTimeout(() => console.log('Hello from the timer'), 0);
		console.log('Hello from the main code');
	```

	1.  `setTimeout` yra apdorojamas, ir kadangi jis asinchroninis, jo _callback_ yra  įdedamas į _callback_ eilę (_callback queue_).
	2.  Kita eilutė, `console.log('Hello from the main code');`, yra iškart išvedama.
	3.  Nors laikmačio trukmė yra 0 milisekundžių, jo _callback_ veiksmas turi laukti, kol kvieimų rinkinys (_call stack_) bus tuščias. Po pagrindinio kodo išvedimo, _callback_ veiksmas yra perkeliamas iš _callback_ eilės (_callback queue_) į kvieimų rinkinį (_call stack_) ir vykdomas.
	4.  Rezultatas - "Hello from the main code" yra išvedamas prieš "Hello from the timer".

56. Ar įmanoma vykdyti JavaScript kodą ne naršyklėje?

	Taip, yra keli būdai vykdyti JavaScript kodą ne naršyklėje. Galima naudoti **Node.js**, **Deno**, **Bun** ar bet kurią kitą JavaScript vykdymo aplinką.

57. Ar įmanoma vykdyti 2 JavaScript kodo eilutes tuo pačiu metu?

	Ne, neįmanoma vykdyti 2 JavaScript kodo eilučių tuo pačiu metu. JavaScript yra vienos gijos (_single-threaded_) kalba, tai reiškia, kad ji gali vykdyti tik vieną kodo eilutę vienu metu. Tačiau įmanoma pasiekti panašų rezultatą (2 JavaScript kodo eilučių vykdymą, tuo pačiu metu) naudojant asinchroninį kodą.

58. JavaScript yra kompiliuojama (_compiled_) ar interpretuojama (_interpreted_) programavimo kalba?

	JavaScript yra interpretuojama (_interpreted_) programavimo kalba. Tai reiškia, kad JavaScript kodas nėra kompiliuojamas (_compiled_) prieš jo vykdymą. Vietoj to, JavaScript variklis (_JavaScript engine_) interpretuoja kodą vykdymo metu.

59. Ar nuorodos (_references_) yra kopijuojamos JavaScript kalboje?

	Ne, nuorodos (_references_) nėra kopijuojamos JavaScript kalboje. Kai priskiriate objektą kintamajam, kintamasis turės nuorodą (_reference_) į objektą. Jei priskirsite šį kintamąjį kitam kintamajam, antrasis kintamasis taip pat turės nuorodą (_reference_) į objektą. Jei pakeisite objektą naudodami vieną iš kintamųjų, pakeitimas bus matomas naudojant kitą kintamąjį.

60. Kas yra _Heap_ ir _Stack_ JavaScript kalboje?

	JavaScript variklyje _Heap_ ir _Stack_ yra dvi skirtingos duomenų struktūros, kurios saugo duomenis skirtingais būdais.

	#### _Stack_

	_Stack_ yra maža, organizuota atminties sritis. Čia saugomos primityviosios reikšmės, funkcijų iškvietimai ir vietiniai kintamieji. Ji laikosi "Last In, First Out" (LIFO) tvarkos, tai reiškia, kad paskutinis į _stack_ pridėtas elementas bus pašalintas pirmas. Kiekvienas funkcijos iškvietimas sukuria naują _stack_ rėmą (_frame_), kuriame yra funkcijos vietiniai kintamieji, grįžimo adresai ir kita kontekstinė informacija.

	#### _Heap_

	_Heap_ yra didelė, daugiausia neorganizuota atminties sritis. Čia saugomi objektai, masyvai ir funkcijos. Kintamieji iš _stack_ (pvz., funkcijose) nurodo vietas _heap_ viduje, kur šios dinamiškai paskirtos struktūros yra saugomos.

	Kai deklaruojate primityvųjį tipą (pvz., skaičių ar boolean), jis paprastai valdomas _stack_ viduje. Bet kai sukuriate objektą, masyvą ar funkciją, jie saugomi _heap_ viduje, o _stack_ laikys nuorodą į tą vietą esančią _heap_ viduje.

	Pavyzdžiui:

	```js
	const name = 'JavaScript'; // Stored on the stack
	const course = { name: 'JS' }; // `course` reference on the stack, actual object { name: 'JS' } in the heap
	```

	Aukščiau pateiktame kode, primityvioji reikšmė `JavaScript` kintamajam `name` yra tiesiogiai saugoma _stack_ viduje. Objektui, priskirtam `course`, jo tikrieji duomenys yra _heap_ viduje, o nuoroda į šiuos duomenis (atminties adreso žymeklis (_memory address pointer_)) yra laikoma _stack_ viduje.

61. Kokia yra JavaScript kablelio operatorius paskirtis?

	Kablelio operatorius `,` įvertina kiekvieną iš savo operandų (iš kairės į dešinę) ir grąžina paskutinio operando reikšmę.

	```js
	let x = 1;
	x = (x++, x);

	console.log(x); // 2
	```

62. Kas yra nulinis susijungimo operatorius (Nullish Coalescing Operator)?

	Nulinis susijungimo operatorius (`??`) grąžina dešinįjį operandą, jei kairysis yra `null` arba `undefined`, kitu atveju jis grąžina kairįjį operandą. Jis naudingas nustatant numatytąsias reikšmes, nelaikydamas neigiamų (_falsy_) reikšmių, tokių kaip `0` ar `''`, neegzistuojančiomis.

	```js
	console.log(null ?? 'hello'); // hello
	console.log(undefined ?? 'hello'); // hello
	console.log('' ?? 'hello'); // ''
	console.log(0 ?? 'hello'); // 0
	```

63. Kokie yra JavaScript loginiai operatoriai?

	JavaScript kalba turi keturis loginius operatorius: `||` (OR), `&&` (AND), `!` (NOT) ir `??` (Nullish Coalescing).

	#### OR (_arba_) (`||`)

	OR operatorius (`||`) grąžina pirmąją teigiamą (truthy) reikšmę arba paskutinę reikšmę, jei nė viena nėra teigiama.

	```js
	console.log('hello' || 0); // hello
	console.log(false || 'hello'); // hello
	console.log('hello' || 'world'); // hello
	```

	#### AND (_ir_) (`&&`)

	AND operatorius (`&&`), dar žinomas kaip loginė jungtis, grąžina pirmąją neigiamą (falsy) reikšmę arba paskutinę reikšmę, jei visos reikšmės yra teigiamos.

	```js
	console.log('hello' && 0); // 0
	console.log(false && 'hello'); // false
	console.log('hello' && 'world'); // world
	```

	#### NOT (_ne_) (`!`)

	NOT (`!`) operatorius tiesiog apverčia savo operando loginę reikšmę.

	```js
	console.log(!true); // false
	console.log(!false); // true
	console.log(!'hello'); // false
	console.log(!0); // true
	```

	#### Nullish Coalescing (_nulinis susijungimas_) (`??`)

	Nullish Coalescing operatorius (`??`) grąžina dešinįjį operandą, jei kairysis yra `null` arba `undefined`, kitu atveju jis grąžina kairįjį operandą. Jis naudingas nustatant numatytąsias reikšmes, nelaikydamas neigiamų (_falsy_) reikšmių, tokių kaip `0` ar `''`, neegzistuojančiomis.

	```js
	console.log(null ?? 'hello'); // hello
	console.log(undefined ?? 'hello'); // hello
	console.log('' ?? 'hello'); // ''
	console.log(0 ?? 'hello'); // 0
	```

64. Kaip sukurti begalinį JavaScript ciklą (_infinite loop_)?

	Norint sukurti begalinį ciklą (_infinite loop_), galima naudoti `while` arba `for` ciklus.

	#### `while` ciklas

	Norint sukurti begalinį ciklą (_infinite loop_) naudojant `while` ciklą, galima naudoti `true` raktinį žodį kaip sąlygą.

	```js
	while (true) {
	  // do something
	}
	```

	#### `for` ciklas

	Norint sukurti begalinį ciklą (_infinite loop_) naudojant `for` ciklą, galima naudoti `true` raktinį žodį kaip sąlygą.

	```js
	for (let i = 0; true; i++) {
	  // do something
	}
	```

65. Kaip naudoti `do...while` JavaScript ciklą?

	`do...while` sakinys sukuria ciklą, kuris vykdo kodo bloką vieną kartą, prieš tikrindamas, ar sąlyga yra teisinga, ir tada kartos ciklą tol, kol sąlyga bus teisinga.

	```js
	let i = 0;

	do {
	  console.log(i);
	  i++;
	} while (i < 3);

	// 0
	// 1
	// 2
	```

66. Kaip veikia `switch` sakinys (_statement_) JavaScript kalboje?

	`switch` sakinys (_statement_) įvertina išraišką, sulygina išraiškos reikšmę su `case` sąlyga (_clause_) ir vykdo atitinkantiems `case` priskirtus sakinius (_statements_), taip pat sakinius  (_statements_), tų `case` sąlygų, kurios seka po atitinkančios `case` sąlygos  (_clause_).

	```js
	const fruit = 'Papayas';

	switch (fruit) {
	  case 'Oranges':
	    console.log('Oranges are $0.59 a pound.');
	    break;
	  case 'Mangoes':
	  case 'Papayas':
	    console.log('Mangoes and papayas are $2.79 a pound.');
	    break;
	  default:
	    console.log(`Sorry, we are out of ${fruit}.`);
	}

	// Mangoes and papayas are $2.79 a pound.
	```

67. Kaip pasirinkti DOM elementus naudojant `querySelector()` ir `querySelectorAll()`?

	Norint pasirinkti elementus DOM, dažniausiai naudojami `querySelector` ir `querySelectorAll` metodai. Jie abu yra dokumento objekto metodai ir priima CSS selektorių kaip argumentą.

	#### `querySelector`

	`querySelector` metodas grąžina pirmą elementą, kuris atitinka nurodytą selektorių. Jei neatitinka nė vieno, jis grąžina `null`.

	```js
	const courseWrapper = document.querySelector('.course-wrapper');
	const courseTitle = document.querySelector('#course-title');
	```

	#### `querySelectorAll`

	`querySelectorAll` metodas grąžina visų elementų, kurie atitinka nurodytą selektorių, _NodeList_ sąrašą. Jei neatitinka nė vieno, jis grąžina tuščią _NodeList_ sąrašą.

	```js
	const courseItems = document.querySelectorAll('.course-item');
	```

68. Kaip sukurti naują DOM elementą?

	Norėdami sukurti naują DOM elementą, galite naudoti `document.createElement` metodą. Jis priima žymos (_tag_) pavadinimą kaip argumentą ir grąžina naują elementą su nurodytu žymos (_tag_) pavadinimu. Taip pat šiam elementui galim nustatyti atributus.

	```js
	const div = document.createElement('div');

	div.id = 'course-wrapper';
	div.setAttribute('data-id', 'javascript');
	console.log(div); // <div id="course-wrapper" data-id="javascript"></div>
	```

69. Kuo skiriasi `appendChild()` ir `insertBefore()` metodai?

	Norint pridėti naują elementą į DOM, galima naudoti `appendChild` arba `insertBefore` metodus.

	#### `appendChild`

	`appendChild` metodas prideda naują elementą kaip paskutinį nurodyto tėvinio elemento vaiką.

	```js
	const courseWrapper = document.querySelector('.course-wrapper');

	const course = document.createElement('div');
	course.id = 'javascript-course';

	courseWrapper.appendChild(course);
	```

	Aukščiau pateiktame pavyzdyje, `course` elementas pridedamas kaip paskutinis `courseWrapper` elemento vaikas.

	#### `insertBefore`

	`insertBefore` metodas prideda naują elementą prieš nurodytą vaikinį elementą.

	```js
	const courseWrapper = document.querySelector('.course-wrapper');

	const course = document.createElement('div');
	course.id = 'javascript-course';

	const courseTitle = document.querySelector('#course-title');
	courseWrapper.insertBefore(course, courseTitle);
	```

	Aukščiau pateiktame pavyzdyje, `course` elementas pridedamas prieš `courseTitle` elementą.

70. Kaip pašalinti elementą iš DOM?

	Norint pašalinti DOM elementą, galima naudoti `remove` arba `removeChild` metodą iš `Node` sąsajos.

	```js
	const courseWrapper = document.querySelector('.course-wrapper');
	const courseTitle = document.querySelector('#course-title');

	courseWrapper.removeChild(courseTitle);
	courseWrapper.remove();
	```

71. Kaip pakelti puslapį į viršų naudojant JavaScript?

	Norint pakelti puslapį į viršų, galima naudoti `scrollTo` metodą.

	```js
	window.scrollTo(0, 0);
	```

72. Kaip gauti elemento išmatavimus naudojant JavaScript?

	Norint gauti elemento išmatavimus JavaScript kalboje, galima naudoti `getBoundingClientRect` metodą.

	```js
	const courseWrapper = document.querySelector('.course-wrapper');
	const dimensions = courseWrapper.getBoundingClientRect();

	console.log(dimensions); // DOMRect { x: 8, y: 8, width: 784, height: 784, top: 8, right: 792, bottom: 792, left: 8 }
	```

73. Ar galima sujungti kelis masyvus į vieną JavaScript kalboje?

	Taip, galima sujungti kelis masyvus į vieną, naudojant `concat()` metodą arba sklaidos (_spread_) operatorių `...` .

	#### `concat()`

	`concat()` metodas naudojamas sujungti du ar daugiau masyvų. Šis metodas nekeičia esamų masyvų, tačiau grąžina naują masyvą.
	
	```js
	const arr1 = [1, 2, 3];
	const arr2 = [4, 5, 6];

	const arr3 = arr1.concat(arr2);
	console.log(arr3); // [1, 2, 3, 4, 5, 6]
	```

	#### Sklaidos (_spread_) operatorius

	Sklaidos (_spread_) operatorius `...` naudojamas išplėsti iteruojamą objektą į argumentų sąrašą.

	```js
	const arr1 = [1, 2, 3];
	const arr2 = [4, 5, 6];

	const arr3 = [...arr1, ...arr2];
	console.log(arr3); // [1, 2, 3, 4, 5, 6]
	```

74. Kaip gauti ekrano matmenis JavaScript kalboje?

	Norint gauti ekrano matmenis, galima naudoti `window.innerWidth` ir `window.innerHeight` metodus.


### Šaltiniai:

-  https://roadmap.sh/questions/javascript

